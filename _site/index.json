{
  "docs/Afslutning.html": {
    "href": "docs/Afslutning.html",
    "title": "Afslutning | dadaPipes",
    "keywords": "Afslutning Kunden har altid ret. Produkt owner dikterer hvad og hvordan at applikationen skal laves. Vi er der blot for at rådgive, ud fra den tekniske viden vi har, og lede kunden ind på hvad det er de gerne vil opnå og hvordan. Man må parkere sit ego for en stund og slippe det løs på StackOverflow udenfor arbejdstid. Som udgangspunkt skal man tænke at PO ikke ved noget som helst om webudvikling og hvilke muligheder der eksisterer og hvad man kan forvente. Derfor er vi nødt til at tage dem i hånden og stille alle de simple spørgsmål som, hvilken besked vil du gerne have tilbage hvis du taster dit password forkert 1, 2 eller tre gange ? og så præsenterer dem for de muligheder der er for feed back. Det er som udvikler arrogant at tro at man ved bedre end PO og derfor er det en essentiel del af udviklingsfasen at spørge ind, både åbent, men også i detaljer. At jonglere med kontakt til PO, dokumentation, front- og backend-udvikling er som at spille 4D-skak. Der er både dybde og bredde at tage højde for, men også en dimension af tid, der styrer, hvornår og hvordan tingene hænger sammen. Hvert træk påvirker ikke kun nuet, men også fremtiden, og alt er forbundet i en større helhed, hvor planlægning og overblik er afgørende for succes. Måske skal dette omskrives og med: Douglas Adams’ \"The Answer to Life, the Universe, and Everything\" (42): Brug dette som en humoristisk henvisning til at finde løsningen: \"Vi er på jagt efter vores egen version af 'svaret på livet, universet og alt', der samler alle tråde.\" Occam's Razor vs KISS ( ikke bandet) \"Vi skal finde en løsning med minimal kompleksitet – som Occam’s Razor foreskriver.\" Andre ting der skal flettes ind i det: Fleksibilitet og skalering: First we take Manhattan, then we take Berlin. Dokumentanion og fordele ved acceptence tests: Ofte når der bliver spurgt ind til hvordan at man sætter sig ind i en kodebase hvor der er manglende eller mangelfuld dokumentation, så er svaret ofte at man skal læse testene for at sætte sig ind i hvad koden gør eller at sætte et breakpoint og hakke sig igennem systemet. Hvis man læser unit tests, så kan man se hvad de enkelte dele i systemet gør, men man for ingen forståelse af hvordan at systemet hænger sammen. Hvis man derimod kigger på acceptence tests, som er det højeste niveau inden for tests og omhandler hvordan en bruger interigerer med systemet, så får man hurtigere et overblik over hvordan at systemet hænger sammen og hvad det gør. Man kunne med fordel dele testene op i 2. Tests for hvad at en bruger vil opnå i en given test, og tests"
  },
  "docs/Arkitektur.html": {
    "href": "docs/Arkitektur.html",
    "title": "Arkitektur | dadaPipes",
    "keywords": "Arkitektur 2 populære arkitekturer der bliver brugt i .NET til webudvikling er Clean Architectur (lagdelt arkitektur) og Vertical Slice Architecture (VSA). Jeg tager udgangspunkt i en API uden et klient (UI) projekt, men har stadig et 'Shared' projekt, for at kunne dele data i C# for både Klient og Server projekterne. Lag delt arkitektur Vertical Slice Arkitektur I en lagdelt arkitektur har man forskellige, typisk separeret af foldere eller projekter. Det kunne være Applications lag med endpoints/controllers, Data lag med repositories og et domæne lag med domæne modeler/ entities. Der findes flere forskellige nuancer af lagdelte arkitekturer, men fællesnævneren er at …. Fordele Tydelig adskillelse af ansvar: Application indeholder forretningslogik. Infrastructure håndterer tekniske detaljer. Domain indeholder centrale objekter og regler. Testbarhed: Du kan teste UserService uafhængigt af databasen ved at mocke IUserRepository. Udvidelighed: Hvis du ønsker at udskifte EF Core med noget andet, behøver du kun ændre UserRepository. Arbejder man på en feature, ved man præcis hvordan at den skal skæres/deles, da hver del af koden har en bestemt plads. Hele kodebasen er bygget op på den samme måde, så det kan fungere som bander på en bowlingbane. Man holder sig inden for banen og skyder ikke ved siden af. Det kan give en mere ensartet kode, hvor man kender flowet på forhånd. Ofte følger denne form for arkitektur SOLID principels og DRY til hvert punktum og komma. De forskellige lag i applikationen kan nemt skiftes ud, da der er en løs kobling mellem lagene og brugen af interfaces typisk er høj, hvilket også gør det nemt at unit teste enkelte metoder. Hvis et af målene er at man nemt kan skifte et lag ud, skal alle dele i det lag have et interface og unit testes. Derved opnår man ikke kun at kontrakten mellem interface og implementiering overholdes, men også at omplementeringen af interfacet overholder kravene, da alle unit tests skal bestå, og man sikrer sig dermed at det er implementeret korrekt. Ulemper Man er tvunget til at dele meget simpel kode ud på flere forskellige filer. Koden er låst fast i det samme mønster igennem hele applikationen, allerede inden at man skriver det første stykke kode. Nogle arktitekturer deler lagene med projekter frem for foldere, for at gøre det nemmere at skifte de forskellige lag ud, i tilfælde af at man skulle få brug for det engang i fremtiden. Et typisk argument i .NET er at man nemmere kan skifte databasen ud med en anden, hvis man bruger repositories og interfaces for de selv samme repositories. Men Microsoft har udviklet en ORM (EF Core) som virker som et repository via DbContext, og den kan bruges på mange forskellige databaser. Høj brug af interfaces og unit tests, hvilket gør det tidskrævende at implementere koden og samtidigt gør koden mere kompleks. Pull requests: Det bliver mere uoverskueligt at gå igennem opdatering af kode der er skubbet til github og få et overblik og de dele af koden der er ændret. På samme måde er det også mere komplekst at godkende en pull request. Clean Architecture eksempel Mappestruktur Jeg har inkludered eksempler på klasser i mapperne, for at illustrerer hvordan det ser ud i en meget lille applikation. Man kan tænke sig til hvordan sværhedsgraden, i at finde rundt i de forskellige mapper, stiger liniært, i takt med at applikationen vokser. Ikke kun på grund af antallet af mapper, men også pga antallet a filer der er i hver mappe. I eksemplet har jeg lænet mig op af High Cohesion/Low Coupling, da relaterede emdpoints er samlet i en UserController, Service metoder er samlet i en UserService osv. Der er low coupling i mellem lagene, via interfaces. Fordelen ved at bruge class library projects er at hver del kan have deres egen afhængigheder og er isolerede i det enkelte class library project. For eksempel er EF Core Nuget pakken isoleret i Persistence projektet i Infrastructure mappen. Presentation (mappe) Ansvar: UI-laget, der håndterer input og output fra brugeren via API'en. API (Class library) Kalder applikationslaget (fx UserService) for at udføre handlinger og returnere resultater til klienten. Presentation/ ├── API/ │ └── UserController Infrastructure (mappe) Ansvar: Implementerer tekniske detaljer, såsom datatilgang eller eksterne services. Infrastructure (Class library project) Implementerer generelle infrastrukturtjeneste interfaces fra domain-laget Repositories (Class library project) Implementerer Repository interfaces fra domain-laget for at kommunikere med databasen. Persistence (Class library project) Database relaterede klasser Infrastructure/ ├── Infrastructure/ │ └── Logger └── FileStorageService └── EmmailService ├── Repositories/ │ └── UserRepository ├── Persistence/ │ ├── DbContext │ └── Migrations Core (mappe) Ansvar: Forretningslogik og applikationsregler. Interfaces (Class library project) Interfaces til datatilgang, så domain-laget er uafhængigt af infrastrukturen. RepositoryInterfaces (mappe) Indeholder interfaces til repositories, som muliggør datatilgang og gør domain-laget uafhængigt af den konkrete databaseimplementering. ServiceInterfaces (mappe) Indeholder interfaces til services, som definerer forretningslogik og gør domain-laget uafhængigt af konkrete serviceimplementeringer. InfrastructureInterfaces (mappe) Indeholder interfaces til infrastrukturtjenester som logning, filopbevaring og email-tjenester, hvilket gør domain-laget uafhængigt af konkrete infrastrukturtjenester. Entities (Class library project) Domæne-entiteter, der repræsenterer konkrete ting i systemet. Application (Class library project) Indeholder forretningslogik relateret til Domæne-entiteter og kalder et relateret repository til datatilgang. Core/ ├── Domain/ │ ├── Interfaces/ │ │ ├── RepositoryInterfaces │ │ │ └── IUserInterface │ │ └── ServiceInterfaces │ │ │ └── IUserService │ │ └── InfrastructureInterfaces │ │ └── ILogger │ │ └── FileStorageService │ │ └── EmmailService │ └── Entities/ │ └── User ├── Application/ │ └── UserService Shared (Class Library Project) Ansvar: Overfører data mellem lag. UserDto (mappe) Indeholder dataoverførselsobjekter relateret til brugere og inkluderer valideringslogik. ├──Shared/ └── UserDto/ └── CreateUserDto └── CreateUserDto.CreateUserDtoValidator Modelering Det er muligt at modelerere på low-level, som [indsæt nogle navne på low-level diagrammer] niveau da man allerede har fastlagt programmeringsmønstre der skal følges. Hvis fokus er på low-level design, så øger det kompleksiten ved at sikre sporbarhed imellem design diagrammer og kode. En interesant bekymrer sig typisk ikke om hvordan at koden er implementeret, men har fokus på interactivitet. Low-level design bør derfor kun benyttes, hvis en en udvikler vil modelere for at få et overblik over en feature, inden at den bliver implementeret. Tests Det er muligt at planlægge unit tests allerede inden at man har implementeret koden, da man ved hvilke dele der skal testes og hvad der skal testes for. Hvilket gør det muligt for UTDD(TODO: internt link \"Unit Test Driven Design\"). Da det primære mål er at kunne skifte hele implementationen of Core laget ud, som er der hvor at alt forretningslogikken er placeret, er det ikke nok kun at dække det med interfaces. Interfaces sikrer en meget begrænset kontrakt til dens implimentation, da den kun sørger for at retur type og argumenter bliver inplementeret. Den sikrer dermed en 'happy path', men sikrer ikke 'edge cases'. Ved at unit teste interfaces, kan man sikre at 'edge cases' også bliver sikret, hvis man har dækket alle interfaces i Core laget, med et Core test projekt. Man deler koden op i lodrette snit, typisk per feature, som er placeret i 1 folder. I en serverside applikation hvor at både front- og backend kører på serveren, kan et snit bestå af en Blazor komponent og alt loggiken der hører til den specifike komponent. I en WebAssembly applikation, som er delt op i flere projekter, vil man have foldere med det samme navn i hver projekt, som har alt hvad der er hører til den specifike feature. Fordele Det er nemmere at overskue en feature når det hele ligger i den samme folder, i stedet for at den er spredt over flere foldere og projekter. I tilfælde at et distribueret system med et Client, Server og Shared projekt, kommer man ikke uden om at det bliver spredt ud, men det er stadig begrænset og folderne hedder det samme og er delt op på samme måde. Da koden er delt op per feature bliver det nemmere, for udviklere der er nye til kodebasen, at sætte sig ind i hvordan den fungere. Det bliver nemmere at debugge koden da alt relevant kode er samlet i den samme folder. Der er ingen kobling imellem de forskellige feature snit, så en ændring i et snit kommer ikke til at påvirke et andet. Det har ingen sideeffekter, som er en ting der får det til at løbe koldt ned af ryggen på mange udviklere, når de skal skubbe kode til production. Udviklere er mere frie til at implimentere den konkrete kode og løse problemerne på en måde de mener er bedst. En feature kan ses som en black box, hvor at man kan sende et request og få et response. Man kan med sikker hånd implementere integration tests (TODO: Acceptence tests (automatiserede) ?), der går på tværs af forskellige dele af systemet, på det højeste niveau, da den berørte kode er samlet 1 sted. Som nævnt under (TODO: Ligger det her under tests eller hvor ?) tests, så er de dele af koden som bliver brugt på tværs af snittene unit testet. Man KAN bruge unit tests i en feature, men det er ikke påkrævet for at sikre sig at brugerens krav er overholdt. Eksempler på hvor at det kunne være en fordel at implementere en unit test, kunne være hvis man har en meget kompleks metode/funktion, hvor man så kan køre den test for at se om den virker efter hensigten, frem for at skulle debugge den hver gang at man laver en ændring i den. Det er dog mere op til den enkelte udviklers præference, frem for et overordnet krav. Man kan sammenligne det med at unit teste private metoder: En privat metode understøtter en public metode og er derved en del af implementeringen af den public metode. På samme måde er en metode i et snit, med til at understøtte en feature i at overholde kravende. Pull request: Det er nemt at se hvad der er ændret tilbage i tiden da koden er samlet i de samme folder/foldere. På samme måde er det også mere overskueligt at godkende en pull request. Ulemper Da der ikke er nogen kode delt imellem lagene, vil man kunne komme ud for at skulle gentage sig selv \uD83D\uDE31, det taler imod DRY ( gentag ikke dig selv ). Regler er til for at brydes, og hvis man er en erfaren udvikler, vil man vide at det ikke alt tid giver mening at være regelrytter. Delt forretningslogik vil man dog presse ned i domæne laget, i de tilfælde hvor det giver mening. TODO: ( SE: Hvordan man udvikler en feature ) Vertical Slice eksempel Mappestruktur TODO: SKRIV OM SÅ DET PASSER FOR VSA: \"Jeg har inkludered eksempler på klasser i mapperne, for at illustrerer hvordan det ser ud i en meget lille applikation. Man kan tænke sig til hvordan sværhedsgraden, i at finde rundt i de forskellige mapper, stiger liniært, i takt med at applikationen vokser. Ikke kun på grund af antallet af mapper, men også pga antallet a filer der er i hver mappe. I eksemplet har jeg lænet mig op af High Cohesion/Low Coupling, da relaterede emdpoints er samlet i en UserController, Service metoder er samlet i en UserService osv. Der er low coupling i mellem lagene, via interfaces. Fordelen ved at bruge class library projects er at hver del kan have deres egen afhængigheder og er isolerede i det enkelte class library project. For eksempel er EF Core Nuget pakken isoleret i Persistence projektet i Infrastructure mappen.\" Infrastructure (mappe) Indeholder infrastrukturtjenester som logning, filopbevaring og email-tjenester. Persistence (mappe) Indeholder database relaterede klasser Domain (mappe) Domæne-entiteter, der repræsenterer konkrete ting i systemet. Infrastructure/ │ ├── Logger │ ├── FileStorageService │ └── EmmailService Persistence/ │ ├── DbContext │ └── Migrations Domain/ │ ├── User Features/ ├── User Features (mappe) Eksemplerne illusterer at en udvikler er fri til at implementerer koden som det passer bedst for den enkelte brugssag. I et simpelt brugstilfælde kan man nøjes med at implementere koden i et endpoint. Eksempel 1 ├── Features/ │ ├── User │ │ ├── Create │ │ │ └── Endpoint.cs I et mere komplekst brugstilfælde kan det være at det giver mere mening at dele koden op i mindre bider, for at øge læsbarheden. I nogle tilfælde kan det være at man har et komplekst data access object som man gerne vil lave en unit test til, så man er fri for at debugge det manuelt, for at være sikker på at det er implementeret korrekt. Eksempel 2 ├── Features/ │ ├── User │ │ ├── Create │ │ │ ├── Endpoint.cs │ │ │ ├── Repository.cs │ │ │ ├── IRepository.cs │ │ │ ├── Mapper.cs │ │ │ └── Service.cs Shared (Class library Project) Ansvar: Overfører data mellem lag. UserDto (mappe) Indeholder dataoverførselsobjekter relateret til brugere og inkluderer valideringslogik. ├──Shared/ └── UserDto/ └── CreateUserDto └── CreateUserDto.CreateUserDtoValidator Modelering Man kan holde det simpelt og fokusere på high-level diagrammer og på hvad interesanten gerne vil med applikationen. Det er mere effektivt at lade udvikleren, der skal implementere en feature, om detaljerne. Derved kan man lade koden diktere hvordan at den skal implementeres(link til Jimmi Bogard video). Det er muligt at modelere på et low-level niveau, men oftest er det mere effektivt at bruge en [TDD](internt link) tilgang til endpoints, og så [lade koden diktere hvordan en feature skal implementeres](link til Jimmi Bogard video). Derved kan man have mere tid og fokus på high-level diagrammer som betyder noget for interesanten, da de som oftest ikke har interesse i at vide hvordan at koden er implementeret. Tests Da hver feature mappe er isoleret fra de andre, kan man nemt debugge en feature for at finde en mulig fejl. Når man ændrer i koden, og får rettet op på fejlen, så er man sikker på at det ikke har sideeffekter til andre features. Den mest effektive tilgang til tests ved VSA er en [ATDD](TODO:internt link) tilgang, med fokus på endpoints. Man kan, men bør ikke fokusere på [unit tests](TODO: internt link), med mindre at man har komplekse objekter, hvor at det kan være tidsbesparende at skrive en test først, i stedet for at debugge for at være sikker på at den gør som den skal. Da de forskellige features har adgang til domæne laget, er det værdifuldt at unit teste alt foretnings logik i domæne laget, for at sikre sig at den gør som den skal. 1 fejl i domænet kan have sideeffekter i flere features og vil ikke være isoleret til domænet selv. Man ser ofte, når man læser om arkitektur, at en bestemt arkitektur passe godt til en bestemt størrelse. Baseret på hvor kompleks den er, hvor nem den er at overskue, hvad teamet kender til, eller andre udvikler baserede parametre. Men det er som nævnt baseret på hvad man tænker som udvikler. Det der burde være i fokus er ikke noget af det overnævnte, men hvad kravene til applikationen er og hvad der passer sig bedst til applikationen. Jo mere kompliseret applikationen er, jo mere koster det at udvikle og vedligeholde. xychart-beta title \"Monthly Sales Data\" x-axis [Jan, Feb, Mar, Apr] y-axis \"Sales ($)\" 0 --> 10000 line [8000, 6000, 4000, 2000] line [2000, 4000, 6000, 8000] Som udgangspunkt er det en go' ide at holde det simpelt(KISS link), og man skal ikke spekulere på hvad det måske kan udvikle sig til engang i fremtiden (YAGNY link), da det som udgangspunkt vil komplisere kodebasen og kompleksitet koster penge i implementering og vedligehold. Der skal derfor være en meget god grund til at man vælger Clean Architektur, for at kunne retfærdigøre den øgede kompleksitet. Med arkitektur i fokus, så er Vertical Slice rchitecture den mest simple at starte ud med. Hver skive har 1 fokusområde og alt hvad den skive skal have er samlet i 1 folder. Hvis man engang i fremtiden skulle få brug for at genbruge domæne delen af applikationen, så kan man opdatere 1 skive af gangen, indtil at man have et domæne der kan skilles fra resten af applikationen, udrulles og deles på tværs af andre projekter. Repositories har sine fordele men er ikke altid bydende nødvendige. Især ikke når man kan bruge en ORM(Object Relational Mapper) som EF CORE, der fungerer som data access lag til en database. Skulle man få brug for at skifte til en anden database (YAGNY), så understøtter EF CORE mange forskellige allerede via DbContext. Når man afsøger kravene til applikationen, kan man i modeleringsfasen, dele applikationen op i dele som i Feature Driven Development 'Theme', 'Epic', 'Feature' og 'User Story', som så kan afspejle mappe strukturen i applikationen, hvilket giver sporbarhed imellem modelen og applikationen. Udover at give sporbarhed, så er der heller ikke så giver det, som applikationen udvikler og udvider sig, en klar afgrænsning af domænet. Noget som ellers kan være svært at nå til enighed i et team. På sigt kan, hvis applikationen bliver stor nok og det giver mening, en del af applikationen nemt skilles fra og håndteres som sin egen service, der kan bruges i andre applikationer."
  },
  "docs/CICD.html": {
    "href": "docs/CICD.html",
    "title": "Continious Intergration/Continious Delivery | dadaPipes",
    "keywords": "Continious Intergration/Continious Delivery CI/CD Tests, Docker. Halloa!!"
  },
  "docs/Docker.html": {
    "href": "docs/Docker.html",
    "title": "Docker | dadaPipes",
    "keywords": "Docker Docker PO I hovedsædet. Gør det muligt for PO at teste funktionalitet, interaktivetet og UI via DockerHub, uden at man skal udrulle systemet. Kan docker fixe (alternativ til) hot reload i Blazor ? Forskel på build i VS 2022 og Docker build time ? Min forståelse er at når man kører en container så opdaterer den kun det kode man har tilføjet efter at have startet den op. Ergo, den skal ikke bygge hele projektet men bygger og tilf'jer kun det nye kode, hvilket i så fald vil udmunde i en hurigere build time og muligvis fixe hot reload."
  },
  "docs/Dokumentation.html": {
    "href": "docs/Dokumentation.html",
    "title": "Dokumentation | dadaPipes",
    "keywords": "Dokumentation Hvad giver mening at dokumentere og hvorfor ? Acceptence tests for at PO og udviklere kan se hvad systemet kan, gør og begrænsninger i forskellige komponenter. Delte objekter: API: Utility: Domæne modeller: Globale objekter: Error response i API. andre globale objekter EKS (?) summary, XML comments, DocFX, GhostDoc Automatiseret dokumentation er tidsbesparende, færre fejl og bliver opdateret automatisk. API: DocFX statisk documentation og .NET .json der kan bruges til API tests i eksemplevis Swagger. Ved at dokumentere Acceptence Tests med xunit.gherkin.quick og DocFX, giver det et overblik for både product owner og udviklere der arbejder op applikationen. Det er især værdifuldt for Product Owner, da de hurtigt kan få et overblik over hvad det at systemet gør, uden at kende til detaljerne omkring hvordan at det gør det. Man sikrer sig også at dokumentationen altid er up to date samtidig med at man sikrer sporbarhed imellem kravene til applikationen og hvordan systemt virker. Ved at dokumentere kravene til applikationen, bliver det nemmere for nye udviklere at sætte sig ind i hvad systemet gør. Ved at dokumentere de dele af koden som man ved bliver brugt af forskellige andre dele af koden og som kan bruges når der laves nye features, så kan man nøjes med at kigge i dokumentationen frem for at grave ned i implementeringe af de forskellige objekter, for at finde ud af hvordan at de virker. Selve implementeringen at et objekt er ofte ikke så interesant. Med en gennemført dokumentation af systemet og kodebasen får man et bedre overblik."
  },
  "docs/EksPåAndvendelse/RandomEksempel.html": {
    "href": "docs/EksPåAndvendelse/RandomEksempel.html",
    "title": "Random Eksempel | dadaPipes",
    "keywords": "Random Eksempel Da jeg startede ud med at lave systemet, så begik jeg så mange fejl. Jeg kodede med hovedet oppe i røven og hev kode ud fra det samme sted. Fik ikke afklaret kravene klart nok, så implementeringen af koden var i mange tilfælde tilfældig, da jeg stødte på komplikationer jeg først opdagede da jeg var i gang med at kode. Meget af det bundede i at der var ting jeg ikke vidste at man kunne gøre og ting jeg ikke vidste skulle afdækkes som et krav og hvilke muligheder der var. Ting som jeg i den grad skal have skrevet ned og systimatiseret, da en fremtidig Product Owner vil stp i samme sted som mig, da jeg startede ud med bygge systemet. Ting som hvad er der af 'response' muligheder i en web form ? Hvilke muligheder er der når man intaster noget korrket eller forkert i et input felt ? Hvad sker der hvis man 'submitter' noget der ikke er korrekt ? Hvad sker der hvis man søger på noget som ikke findes ? Hvad hvis der opstår en fejl i systemet ? Er det noget brugeren kan rette op på ? giv oplysende besked om hvordan brugeren retter op på fejlen. Er det noget brugeren ikke kan rette op på ? : giv en generisk fejl besked. Osv.. Alle de ting er noget der skal afklares når man har en snak om kravene til systemet og de forskellige dele. Mange af de ting jeg har skrevet om i bloggen er født ud af frustration over min manglende viden om hvilke muligheder jeg skulle afdække i en web applikation i forskellige brugssager. Nogle ting anede jeg ikke eksisterede før at jeg gik i gang med at skrive bloggen, men efter at jeg havde været igennem frustrationerne med at udvikle systemet og samtidigt gjort mig nogle tanker om hvordan at man kunne gøre det nemmere, fik jeg afsøgt nogle områder hvor at jeg kunne finde forskellige løsninger, sammenligne de forskellige værktøjer og vælge det som passer bedst ind i systemet. Ved at udvikle et projekt alene og skulle håndtere kravs insdsamling, via kommunikation med Produkt Owner, og en full stack web applikation, har det givet mig en bedre forståelse for sammenhængen mellem de forskellige dele. Det er absolut kun i retro perspektiv at det er gået op for mig hvor meget at Produkt Owner skal være i fokus, for at levere et brugbart system. Det vigtigste at jeg har lært i den her proccess, er at det i sidste ende, er Product Owner der bestemmer hvad der skal laves, hvordan det skal laves og hvornår det skal laves. Man kan så præsentere hvilke muligheder der er, baseret på ens viden på området. Det gælder både for hvilken type af applikation man vælger, baseret på forventede omkostninger af udvikling, vedligeholdelse og drift. Jo mere viden man har på området, des større en palette af muligheder kan man præsentere for Product Owner."
  },
  "docs/TechRamme/Api.html": {
    "href": "docs/TechRamme/Api.html",
    "title": "API | dadaPipes",
    "keywords": "API Skriv om API, controllers, minimal API og FastEdnpoints, helt overordnet. Kode Eksempel: Opdatering af det mest komplekse objekt og hvordan det håndteres i interactive Server og interactive WebAssembly."
  },
  "docs/TechRamme/Blazor.html": {
    "href": "docs/TechRamme/Blazor.html",
    "title": "Blazor Varianter | dadaPipes",
    "keywords": "Blazor Varianter Overvejelser og Sammenligning af Blazor rammer Jeg har undersøgt og sammenlignet de forskellige relevante Blazor varianter i .NET 8.0 Blazor Web App Introduktionen af Blazor Web App i .NET 8.0 har gjort det muligt at mixe forskellige render modes i Blazor, til forskel for .NET 7.0 hvor man kun kunne vælge imellem Blazor Server og Blazor WebAssembly. Man kan sætte rendermode for hele applikationen og ikke tænke mere over det eller man kan sætte en rendermode for hver individuel komponent, så man ikke er tvunget til at bruge enten server rendering eller webassembly rendering for hele applikationen. På den ene side giver det mere fleksibilitet, men på den anden side giver det mere kopmleksitet, hvilket jeg dækker senere. I nogle tilfælde kan det give mening at have forskelig rendermode, men for større dele af applikationen, som en epic (en gruppering af features, eller for en gruppe af epics der er relaterede). (TODO: INDSÆT INTERNT LINK TIL DER HVOR JEG BESKRIVER FEATURES OG HVORDAN MAN KAN ORGANISERE KODEN DYNAMISK, UD FRA KRAVENE, I TAKT MED AT APPLIKATIONEN VOKSER). Begge har SPA funktionallitet, så de kan opdatere enkelte komponenter på en side uden at lave en fuld page refresh. Interactive Server Interactive WebAssembly Interactive Auto Blazor Standalone Progressive Web App Sådan fungerer det Klienten viser kun det indhold som skal bruges, og bliver sendt via en SignalR-forbindelse, der muliggør realtidskommunikation mellem serveren og klienten gennem websockets (eller alternative protokoller som Server-Sent Events eller Long Polling, hvis websockets ikke er tilgængelige). Interaktivitet Brugeraktivitet behandles direkte på serveren af ASP.NET Core runtime. Stateful (tilstandsfuld): Applikationens tilstand er afhængig af serveren og håndterer forbindelsen for alle forbundne klienter og opdatering af UI. Fordele: Hurtig initial indlæsning da alt bruger aktivitet på siden forgår direkte via serveren. Skal kun downloade Java Script bundle displaye den første side inklusiv HTML og CSS for den første side. Uanset hvor stor applikationen er, vil den loade hurtigt. Lavere krav til klientens ydeevne, da alt beregnes på serveren. Man behøver kun 1 projekt da alt kører på serveren. Koden er simplere og man er ikke tvunget til at have et API lag. Ulemper: Netværk: Afhængighed af en stabil netværksforbindelse. Hvis forbindelsen afbrydes, mister applikationen sin funktionalitet. Omkostninger: Høj belastning på serveren, hvilket kan resultere i øgede omkostninger, især ved mange samtidige brugere eller meget aktivitet. Udsving i netværksforbindelsen kan påvirke brugeroplevelsen negativt. Sikkerhed Da hele applikationen ligger på serveren kan man sikre at det kun er brugere med de rette brugsrettigheder der har adgang til specifike begrænsede komponenter. Derfor(!) kan man sikre følsom kode direkte i en komponent (UI). ( Hård nød er knækket.. ). Hele koden holdes sikker på serveren og komponenter kan kun tilgås hvis man har brugerrettigheder til at tilgå dem. Validering af data kan derfor foregå direkte i UI, da det kun er autoriserede brugere der har adgang til serveren. Man skal selvfølgelig sørge for at de kun kan sende og modtage data der er relevante for dem, så de ikke kan fucke med hele systemet, men kun hvad der vedrører dem selv. Sådan fungerer det Hele frontend delen bliver downloaded og cached i klientens browser, inclusiv .NET WebAssembly runtime. UI og brugeraktivitet håndteres direkte i browseren. Ved første indlæsning af en komponent downloades hele .NET runtime sammen med applikationen til browseren og caches, hvor koden eksekveres i WebAssembly-format. API-kald og andre interaktioner med serveren håndteres via http(s) eller andre forbindelser som websockets. Interaktivitet Brugeraktivitet håndteres i browseren på klienten via den WebAssembly baserede Blazor runtime. Stateless (tilstandsløs): Den håndterer tilstanden af applikationen i browseren, uafhængig af serveren, da alt er lagret i browseren. Fordele Kan bruges offline, efter at den er downloaded, da frontend delen ligger i browseren, derfor kan den stadig fungere, selv hvis netværksforbindelsen svigter efterfølgende. Hurtig UI-reaktionstid, da al interaktivitet udføres lokalt i browseren uden afhængighed af netværksforbindelsen, kan man opnå en hastighed der er det tæt på desktop app hastighed. Bedre skalerbarhed, da klient og server kan udvikles og skaleres separat. Nemmere vedligehold i tilfælde af en omfattende applikation, da kommunikationen imellem front- og backend foregår via HTTTP(S), er der en meget løs kobling og to udviklere kan arbejde i hver deres ende, uden at påvirke hinanden. Server projektet kan bruges til forskellige klienter. Ulemper Længere initial indlæsningstid da hele frontend delen skal downloades før at en bruger kan interiger med appen. Kræver en mere kraftfuld klientenhed, da al interaktion foregår lokalt i browseren. Er afhængig af en .NET backend for at kunne fungere, og skal ligge på den samme server, da det er backend der 'serverer' frontenden delen til browseren. Øget kompleksitet: Kræver et seperat server projekt i form af en API og typisk også et delt projekt bibliotek der har objekter til at transportere data imellem front- og backend. Implimenterer CORS for at begrænse hvilke domæner der har adgang til API’en. Sikkerhed Validering i UI er ikke beskyttet da det kan manipuleres direkte i browseren. Oven i hatten, så er alle UI komponenter downloaded og catched i browseren og en bruger har derfor adgang til alle dele af frontend delen. Validering SKAL derfor sikres på backend delen (serveren) for at være sikker. Du må ikke sige det til nogen.. men hvis man højreklikker på et website, trykker inspect, klikker på 'application' knappen, kan man finde filerne under 'cache storage'. Ingenting er gemt eller glemt i Dev tools. De forskellige dele af UI er derfor IKKE sikret imod brugere uden de rigtige retigheder. Den begrænsede adgang man kan tilføje i Blazor er rent kosmetisk. Derfor er man nødt til at sikre sin API og det er ikke nok bare at sikre sin UI komponenter. Fungerer på samme måde som Blazor WebAssembly, men bruger .NET runtime på serveren indtil at hele applikationen er downloaded og catched i browseren. Blazor Standalone er en bunke statiske filer som HTML CSS of Java Script. Den har den de samme fordele og ulemper som Blazor Standalone, men adskilder sig stadig på nogle punkter. Den er server uafhængig. Den er uafhængig af .NET og kan hostes på en hvilken som helst server der kan sende filerne til borowseren. Skal man sikre foretningslogik eller databaseadgang, skal den kommunikere med en API. Fordele Blazor Standalone templated understøtter Progressive Web App, som det eneste template. Ulemper Det er et sandt mareridt at sikre forbindelsen mellem Standalone og en API. Den officielle dokumentation opfordrer til at man bruger OpenID Connect (OIDC) Identity Provider (IP), som er et tredje parts bibliotek der håndterer tokens uden for applikationen. Den typiske brugssag er Social Media login, så man kan logge ind via Google, Facebook, X, Twitter etc. Problemet er at mange Auth leverandører ikke har lavet noget til Blazor Standalone så man hurtigt kan spinde Authentication op. En mulig årsag er at Blazor som statiske filer, ikke er nært så populært som React, Angular, Vue. Det er IKKE en mulighed at vælge authentication i Blazor Standalone templated, så man er overladt til sig selv. Der findes meget sparsom dokumentation om hvordan man sikrer Blazor Standalone med cookies, hvilket er det rekomenderede, da browseren håndterer cookies, uden at eksponere dem for Java Script. Idioten her fattede ikke en skid af alt det, før efter at have brugt 4 uger på at sikre Blazor Standalone med cookies, hvilket i den grad øgede kompleksiteten i frontend delen. Til gengæld er jeg fri for at være afhægig af en tedje part udbyder, og kan sikre applicationen via Microsoft Identity endpoints eller lave mine egne ( hvis ikke at jeg har brug for en lang række endpoints jeg ikke skal bruge). Hele applikationen kan downloades til en klient. Ordet ’Progressive’ kommer af at en bruger starter med at opdage applikationen, som kører i en browser, og derefter kan progress/fortsætte med at installerer applikationen på sin enhed. Fordele Kan kører offline og med det samme, uafhængig af netværksforbindelse, hvis applikationen er downloaded. Kan kører i sit eget vindue og ikke kun et browser vindue. Startes fra en brugers Operations Systems start menu eller skrivebord. Modtage push notifikationer og håndtere baggrunds tasks via en serviceworker, selv hvis en bruger ikke bruger applikationen. Kan bruges alle klienter der har en browser, som desktop, laptop, tablet og mobiltelefon. Kan downloades fra App Store. Har sit eget icon. Ulemper Offline support er kun tilgængelig hvis applikationen er udrullet. Man kan kun manuelt teste applikationen i offline tilstand efter at den er udrullet. Updateringer er kun tilgængelige hvis en bruger lukker helt ned for applikationen. Det er ikke nok, kun at refreshe browseren. Som udvikler skal man være opmærksom på det og det skal kommunikeres til brugerne. Hvis der udrulles en opdatering som ikke kan bruges med en tidligere version, er der risiko for at en bruger ikke kan bruge applikationen og samtidigt ikke har nogen som helst ide om hvorfor at den ikke kan bruges ( noget som folkene bag NemID ikke havde prioriteret som et essentielt krav. Rant out ). Hvis en bruger ikke har netværksforbindelse, kan man ikke authentikeres og få en access token, og har derved ikke adgang til dele af applikationen som kræver authentikering. Begrænsninger Den har IKKE adgang til klientens Operations System, da den kører i browserens sandbox, så den kan ikke gøre brug af eksempelvis kammera på en telefon. Til gengæld gør det den mere sikker, da den ikke kan manipulere, opsnappe eller plante ting i klienten. Læringsmål Viden (Huske og Forstå) Jeg kan identificere de forskellige Blazor rendermodes Jeg har viden om de forskellige Blazor rendermodes, herunder Blazor Server, Blazor WebAssembly og Blazor Web App med Interactive Auto. Jeg kan beskrive forskellene mellem Blazor Server og Blazor WebAssembly Jeg forstår de grundlæggende forskelle i arkitektur og performance, som adskiller Blazor Server og Blazor WebAssembly. Jeg kan forklare anvendelsen af Blazor rendermodes i webapplikationer Jeg har viden om, hvordan Blazor rendermodes anvendes i forhold til specifikke webapplikationers krav til skalering, hastighed og brugeroplevelse. Færdigheder (Anvende og Analysere) Jeg kan anvende Blazor rendermodes i udvikling af en webapplikation Jeg er i stand til at vælge og implementere den rette Blazor rendermode baseret på applikationens krav og miljøforhold. Jeg kan analysere, hvilken Blazor rendermode der er mest effektiv i et givet scenarie Jeg kan vurdere behovene for en applikation og analysere, om Blazor Server eller Blazor WebAssembly vil være mest effektiv i forhold til performance, sikkerhed og netværkskrav. Jeg kan optimere en Blazor-applikation ved at vælge passende rendermode Jeg er i stand til at vælge den rette Blazor rendermode for at optimere både performance og brugeroplevelse i en webapplikation. Kompetencer (Evaluere og Skabe) Jeg kan evaluere de tekniske og praktiske konsekvenser af valget af Blazor rendermode Jeg kan vurdere, hvordan valget af Blazor rendermode påvirker faktorer som sikkerhed, netværksafhængighed og applikationens skalerbarhed. Jeg kan skabe en webapplikation, der kombinerer Blazor Server og Blazor WebAssembly på en hensigtsmæssig måde Jeg er i stand til at kombinere forskellige Blazor rendermodes i én applikation for at opnå optimal performance og funktionalitet, afhængigt af de specifikke krav. Jeg kan kombinere Blazor rendermodes med designmønstre for at opnå et specifikt mål Jeg kan integrere Blazor rendermodes med passende designmønstre (fx client-side og server-side separation) for at opnå applikationens mål om fleksibilitet, effektivitet og vedligeholdelse."
  },
  "docs/TechRamme/MudBlazor.html": {
    "href": "docs/TechRamme/MudBlazor.html",
    "title": "MudBlazor | dadaPipes",
    "keywords": "MudBlazor"
  },
  "docs/TechRamme/TechRamme.html": {
    "href": "docs/TechRamme/TechRamme.html",
    "title": "Valg af teknologiramme | dadaPipes",
    "keywords": "Valg af teknologiramme Jeg har valgt Blazor og .NET som fundament for udviklingen af applikationen, fordi disse teknologier opfylder både de overordnede krav for applikationen og understøtter en struktureret tilgang til webudvikling. Dette indebærer en klar adskillelse mellem frontend og backend, hvor Blazor håndterer præsentationslaget og .NET sikrer en solid backend med skalerbare løsninger. Adskillelsen gør det nemmere at vedligeholde og skalere applikationen, da hver del kan testes og implementeres uafhængigt af hinanden. Viden om valget af Blazor og .NET Valget af Blazor og .NET er baseret på teoretisk og praktisk forståelse af deres styrker: Blazor Blazor gør det muligt at udvikle moderne, interaktive brugerflader direkte i C#. En stor fordel er, at Blazor også understøtter JavaScript, hvilket åbner op for brug af JavaScript-biblioteker, fx til kompleks drag-and-drop-funktionalitet. .NET .NET sikrer en skalerbar backend, hvor data kan håndteres sikkert og effektivt, fx via CRUD-operationer til databasen. .NET muliggør også integration med forskellige klienter og eksterne systemer, hvilket er vigtigt for krav som datalagring og brugerautentifikation. Færdigheder i valget af teknologier Min proces med at vælge teknologier afspejler en systematisk tilgang: Litteratursøgning og analyse Jeg har undersøgt teknologier inden for mit erfaringsområde, som .NET og JavaScript, og vurderet deres egnethed til at opfylde projektets krav. Microsofts officielle dokumentation er løbende blevet anvendt som kilde, selvom den kan være udfordrende og kræver en aktiv indsats for at holde sig opdateret. Diskussion af brancheaspekter Jeg overvejede omkostninger og risici ved at vælge Blazor i forhold til mere udbredte teknologier som React, Angular og Vue. På kort sigt vurderede jeg, at Blazor er en fordel på grund af min stærke erfaring med C#. På længere sigt er der dog en vis usikkerhed omkring Blazors langsigtede popularitet i branchen. Især da det før er sket at Microsoft har lagt adskillige teck rammer i graven førhen. Løsningsvurdering Teknologierne blev vurderet ud fra de overordnede krav: Blazor muliggør avanceret frontend-udvikling og integration af JavaScript-funktionalitet. .NET håndterer dataintegritet og sikkerhed via implementering af fx login-funktioner. Kompetencer opnået gennem valget Ved at vælge Blazor og .NET demonstrerer jeg evnen til selvstændigt at sætte mig ind i nye teknologier og relatere dem til relevante fagområder. Perspektivering Teknologierne er ikke kun relevante for denne specifikke applikation, men kan også anvendes i andre løsninger, der kræver høj skalerbarhed, hurtig brugerinteraktion og sikkerhed. Relatering til uddannelsens emneområder Valget bygger på min eksisterende viden om programmeringssprog som C# og .NET, mens det også udfordrer mig til at lære nye tilgange, som Blazors komponentbaserede udvikling og integration med backend via RESTful API’er."
  },
  "docs/TeckRamme.html": {
    "href": "docs/TeckRamme.html",
    "title": "| dadaPipes",
    "keywords": ""
  },
  "docs/Tests.html": {
    "href": "docs/Tests.html",
    "title": "Tests | dadaPipes",
    "keywords": "Tests Tests: I forskellige online forumer er tests et tema som bliver diskuteret meget og bølgerne kan gå højt. Ofte er det baseret på præferencer frem for funtionalitet og værdi. Unit tests er noget som udviklere beekymrer sig om og ikke et mål for Produkt owner. Unit tests er til for at sikre at mindre dele af koden fungerer efter hensigten, også hvis der bliver ændret i implementeringen af koden, på et senere tidspunkt. Hvis koden der bliver testet kun er brugt 1 sted, giver det ikke meget værdi at teste den, da det vil være nemt at debugge koden og finde fejlen. Er koden brugt flere steder i applikationen kan påvirke alle de steder i applikationen som bruger den del af koden. Derfor er det vigtigt at få testet den. Fokuspmråder for unit tests vil derfor være metoder i bibilioteker, utility klasser og domæne modeler. Ved at teste så højt oppe i systemet som muligt og fokusere på hvad brugerens krav er, er implementeringen af den undleæggende kode mere fleksibel, da ændringer i koden ikke bryder med brugerens krav. (Hold det op imod public vs private tests: \"There is some debate among practitioners of TDD, documented in their blogs and other writings, as to whether it is wise to test private methods and data anyway. Some argue that private members are a mere implementation detail that may change, and should be allowed to do so without breaking numbers of tests. Thus it should be sufficient to test any class through its public interface or through its subclass interface, which some languages call the \"protected\" interface.[14] Others say that crucial aspects of functionality may be implemented in private methods and testing them directly offers advantage of smaller and more direct unit tests.[15][16]\" https://en.wikipedia.org/wiki/Test-driven_development) Der er eksiterer kun 1 mål ( vejen er målet (?)). Der findes kun 1 form for tests. I yoga findes der, på trods af ihærdige forsøg på at sælge alt muligt andet, kun en yoga stilling, skrædderstillingen. Det er den stilling hvor at kroppen kan slappe mest af og derved den bedste stilling til at meditere og opnå oplysning. Alle andre yoga øvelser eksisterer kun som støttende øvelser, for at gøre det nemmere at kunne side i en skrædderstilling. I webudvikling findes der kun 1 form for test, acceptence test. I fuld stack vil det være en test der tager udganspunkt i UI og i en API som konsumeres af andre vil det tage udganspunkt i et endpoint. Alle andre tests eksiterer kun som støttende tests, der gør det nemmere at sørge for at acceptence testen lyser grøn. Da acceptence testen er udviklet i sammarbejde med product owner. er det på samme måde som skrædderstillingen i yoga, den test der gør det nemmest for en udvikler at slappe af i kroppen. Tengiz Tutizani giver en forklaring på hvordan at man kan automatisere Acceptence tests i .NET. Støttende tests (unit tests osv): ved komplekse metoder ( fuck mit komplekse objekt der skal opdateres og alle de ting der skal tjekkes for!! ) (Derfor er det også nemmere at finde frem til acceptence tests med PO. Det ansvar ligger hos dem, da vi jo ikke kan læse deres tanker og gerne skulle undgå at være arogante). TODO: (link til fetature page) Eksempel på en feature og acceptance test Rød, Grøn, Omstrukturer. Regler at støtte sig op af: Man skal kunne læse et endpoint eller metode på en skærm uden at scrolle. Kan man indsætte en kommentar om, hvordan koden virker, kan det indikere, at koden skal opdeles i mindre, selvforklarende dele. Acceptence test der hvor at det kommer tættest på en bruger og samtidigt kan automatiseres: Frontend Komponent => Service klassen for den enkelte komponent. Ved at bruge en service klasse for en komponent som udgangspunkt for en acceptence test, så har man frie tøjler til at ændre i UI og de klasser som Service klassen sender og modtager data fra. Det vil sige at den kan bruges hvis den kalder andre klasser direkte eller kalder en API. Tests (acceptence tests) som dokumentation. Ny Viden !!!! ATDD (acceptence test driven design), UTDD (unit test driven design), BDD (behavior driven design). [UTDD](\"Unit Test Driven Development\") er målrettet udvikleren der skal implementere koden eller testeren der skal skrive tests inden implimentering af koden. Bruger man en [lagdelt arktitektur](TODO: internt link), hvor at hvor at de forskellige dele af koden har faste pladser i hver deres lag, kan man modelere koden på forhånd og det er muligt for en tester at skrive tests, før at en udvikler implementerer koden. (TODO: Eksempel med Low-level diagram). [ATDD](\"Acceptence Test Driven Development\") er målrettet udviklere, testere og forretningsinteressenter. Bruger man en arkitektur som giver udvikleren mere frie tøjler, som eksempelvis i [VSA](TODO: internt link \"Vertical Slice Architectur\"), vil det være sværere at modelere på et low-level niveau, og for en tester at skrive unit tests før implementering af koden. Tests i Client og API. Da der kan være et team der atbejder på hver især Client og Server projektet, kan man med fordel lave både acceptence tests i klient projektet og intergration tests for endpoints i API'en. Kom ind på Publlic vs Private tests og sammenlign det med acceptence test/intergration tests af endpoints. Hvad der giver mest værdi for den tid man bruger på dem og at det giver mere frihed til at ændre i koden uden at man kommer til at bryde unnit tests. The Magic Tricks of Testing by Sandi Metz DER ER INDEKSERING MED TIDSPUNKTER I KOMMENTARENE, BRUG DEM!. Indsæt links: ... Xunit.Gherkin.Quick Reqnroll User Stories"
  },
  "docs/Udvikling.html": {
    "href": "docs/Udvikling.html",
    "title": "Udviklings metoder | dadaPipes",
    "keywords": "Udviklings metoder TODO: opdtater: Ser man bort fra projekthåndteringen, som jeg ikke dækker i denne blog, og fokuserer på udviklingsmetoden så .. ( hvad er det egentlig at jeg gerne vil have fokus på her ? ) En kort beskrivelse af nogle iterative systemudviklings metoder for at dække de relevante områder. Eksempler på udviklings metoder Feature-Driven Development Test-Driven Development Behavior-Driven Development Grundlæggende principper og tilgang FDD er en model-drevet proces, hvor udviklingsarbejdet struktureres omkring små, veldokumenterede funktioner, der kan implementeres på få dage. Fokus ligger på at opretholde kontinuerlig fremdrift og at levere funktionalitet, der er reel og målbar. De 5 processer i FDD FDD følger fem nøgleprocesser: Udarbejdelse af en overordnet model (Develop an Overall Model): Projektet starter med en forståelse af domænet og en model, som beskriver systemets kernestruktur og -adfærd. Dette involverer workshops og samarbejde mellem udviklere og domæneeksperter. Udarbejdelse af en funktionel liste (Build a Features List): Udviklerne opdeler systemet i mindre dele, kaldet funktioner. Funktionerne beskrives som \"handlinger udført på et resultat for en given kunde\" og organiseres i områder (business domains). Planlægning baseret på funktioner (Plan by Feature): Funktionerne prioriteres og grupperes i udviklingsmilepæle. Denne proces skaber en detaljeret plan, som guider det iterative arbejde. Design af funktioner (Design by Feature): Hver funktion designes af et lille team i tæt samarbejde, hvor designet sikrer, at funktionen kan implementeres på en struktureret måde. Implementering af funktioner (Build by Feature): Funktionerne kodes, testes og integreres i systemet. Denne proces gentages iterativt, indtil projektet er færdigt. Wikipedia Test-Driven Development (TDD) er en softwareudviklingsmetodologi, hvor testskrivning er integreret som en central del af udviklingsprocessen. Det er en iterativ udviklingsmetode, der fokuserer på at skrive tests før implementering af funktionalitet. Hovedidéen bag TDD TDD har som kerneprincip at skrive automatiserede tests for den ønskede funktionalitet, før selve implementeringen påbegyndes. Det hjælper med at sikre, at al kode, der skrives, opfylder kravene og fungerer korrekt. Denne tilgang understøtter hurtigere fejlidentifikation og sikrer, at ny kode ikke bryder eksisterende funktionalitet. TDD-processen TDD følger en fast cyklus, kendt som Red-Green-Refactor: Red (skriv en test) Start med at skrive en test, der beskriver en ny funktion eller en ændring. Testen skal fejle, fordi funktionaliteten endnu ikke er implementeret. Green (implementer funktionalitet): Skriv netop nok kode til at få testen til at bestå. Dette sikrer, at udviklingen er fokuseret og minimal. Refactor (forbedr koden): Optimer koden uden at ændre dens adfærd. Refactorering sikrer, at koden er nemmere at læse og vedligeholdelsesvenlig, mens alle tests stadig passerer. Processen gentages for hver ny funktion eller ændring, hvilket sikrer en iterativ og kontrolleret udviklingsproces. Levende dokumentation: Tests fungerer som dokumentation for systemets funktionalitet og kan bruges til at forstå, hvad koden gør. Eksempel på TDD i praksis Lad os sige, at vi skal udvikle en funktion til at beregne summen af to tal: Red: Skriv en test, der kontrollerer, om Add(2, 3) returnerer 5. Testen fejler, fordi funktionen endnu ikke er implementeret. Green: Implementér en simpel version af funktionen: public int Add(int a, int b) { return a + b; } Testen består nu. Refactor: Overvej, om koden kan optimeres eller generaliseres. Wikipedia Behavior-Driven Development (BDD) er en softwareudviklingsmetodologi, der bygger videre på Test-Driven Development (TDD) og fokuserer på at fremme samarbejde mellem udviklere, testere og forretningsinteressenter. BDD er designet til at hjælpe teams med at forstå og definere, hvordan en applikation skal opføre sig i forskellige situationer. Hovedidéen bag BDD BDD sigter mod at bygge en fælles forståelse af applikationens krav ved at beskrive dem i et simpelt og klart sprog, der er forståeligt for både tekniske og ikke-tekniske interessenter. Fokus er på at definere \"adfærden\" (behavior) af softwaren i forhold til forretningsværdi og brugeroplevelse. Denne tilgang gør brug af specifikationer skrevet i naturligt sprog kombineret med eksekverbare tests, der fungerer som dokumentation for applikationens forventede adfærd. Nøgleprincipper i BDD Samarbejde mellem roller: BDD fremmer samarbejde mellem udviklere, testere og forretningsinteressenter for at sikre, at alle har en fælles forståelse af kravene. Brug af naturligt sprog: Krav beskrives ofte i et format som Gherkin-syntaks, hvilket gør det lettere at dele og forstå. Eksekverbare specifikationer: Testene fungerer både som kravspecifikation og dokumentation. De kører automatisk og bekræfter, at applikationen opfører sig som forventet. BDD's struktur: Given-When-Then BDD bruger ofte et Given-When-Then mønster til at definere funktionaliteter og scenarier: Given: En given kontekst eller forudsætning. When: En bestemt handling eller hændelse. Then: Den forventede adfærd eller resultat. Eksempel: Scenario: User logs in successfully Given the user is on the login page When they enter valid credentials Then they should be redirected to the dashboard Cucumber: Bruges til at skrive og køre Gherkin-scenarier. SpecFlow: En .NET-implementering af Cucumber. Disse værktøjer integrerer med testautomatiseringsværktøjer og gør det muligt at køre scenarierne som testcases. Wikipedia. Eksempler på brug af termer i forhold til Minimal API vs. Controllers Når man beslutter, hvilke termer der passer bedst i en given situation, afhænger det af, om man arbejder med Controllers eller Minimal API, da strukturen og organiseringen af kode varierer. Controller Minimal API Bruger man controllers i .NET, vil det være en ide at tænke over hvad der dækker en gruppe af endpoints (TODO: eksempel). Bruger man Minimal API, hvor at et endpoint kan være i en fil for sig selv, kan man reflektere over hvilken term man bruger for 1 enkelt endpoint (TODO: eksempel). Eksempel: Brug af termer for grupperede endpoints Theme (højere niveau): \"User Management\" kan være temaet for alle endpoints, der håndterer brugere. Epic: \"Manage Users\" kan være en overordnet epic, som beskriver flere funktioner såsom oprettelse, redigering, og sletning af brugere. Feature: En feature kan være \"User Registration\". Story: En specifik story kan være \"As an admin, I want to register a new user with email and password.\" Konkrete eksempler på endpoints i en UserController: POST /users – Opret bruger (story for User Registration). GET /users/{id} – Hent bruger. PUT /users/{id} – Opdater bruger. DELETE /users/{id} – Slet bruger. Her vil en controller give mening som en gruppering for endpoints relateret til \"User Management\", og man kan bruge termer som feature eller story til at specificere formålet med hvert endpoint. Med Minimal API kan hvert endpoint implementeres uafhængigt, ofte i sin egen fil. Dette gør det muligt at tænke på hvert endpoint som en isoleret enhed, og terminologien kan tilpasses denne granularitet. Eksempel: Brug af termer for enkeltstående endpoints Feature: Et enkelt endpoint kan ses som en feature i sig selv, fx \"User Registration\". Story: Et endpoint kan implementere en specifik story, fx \"As an admin, I want to delete a user by ID.\" Konkrete eksempler på Minimal API-endpoints i separate filer: CreateUserEndpoint.cs: Copy code app.MapPost(\"/users\", (UserDto user) => { // Logic for creating a user }).WithTags(\"User Management\"); Term: Feature/story → \"User Registration.\" DeleteUserEndpoint.cs: Copy code app.MapDelete(\"/users/{id}\", (int id) => { // Logic for deleting a user }).WithTags(\"User Management\"); Term: Story → \"Delete a user by ID.\" Med Minimal API kan man fokusere på mere granulære termer, da hvert endpoint ofte er implementeret for sig selv og ikke nødvendigvis grupperes naturligt som i controllers. Valget af termer afhænger af, hvordan kodebasen er struktureret: Controller-tilgang: Brug termer som theme og epic til at beskrive grupper af endpoints og feature eller story til at beskrive individuelle endpoints inden for en gruppe. Minimal API: Brug mere detaljerede termer, hvor hvert endpoint kan beskrives som en feature eller story, da de ofte ikke grupperes på samme måde. Det vigtigste er, at teamet er enige om terminologien og dens anvendelse. Hvordan kagen skal skæres og med hvilke værktøjer er ikke hugget i sten. Det vigtigste er at man kender mulighederne så man kan bruge dem som det passer bedst."
  },
  "docs/processen.html": {
    "href": "docs/processen.html",
    "title": "Processen | dadaPipes",
    "keywords": "Processen"
  },
  "implementering/WebApi.html": {
    "href": "implementering/WebApi.html",
    "title": "Web API | dadaPipes",
    "keywords": "Web API"
  },
  "implementering/authentication.html": {
    "href": "implementering/authentication.html",
    "title": "Authentication | dadaPipes",
    "keywords": "Authentication Authentication i Blazor Standalone er et sandt mareridt. Det kan få selv den mest hårdhudede udvikler til at tvivle på sit erhverv. Kommer snart ..."
  },
  "implementering/blazor.html": {
    "href": "implementering/blazor.html",
    "title": "Blazor | dadaPipes",
    "keywords": "Blazor Intro Jeg havde valgt Blazor Standalone fordi at jeg var sikker på at det var det eneste der understøttede PWA, hvilket var et vigtigt krav til applikationen. Men det viste sig senere, efter at have udviklet den første Epic, at det ikke kun var Standalone der understøttede PWA. Det var en dyr fejl, da det gjorde mange ting meget mere besværligt. Af skade bliver man klog, men lige det her kunne jeg godt have været foruden. Da Blazor Standalone, som med React, Vue og Angular, ikke kræver en .NET server til at serve UI'en, er der ikke helt så meget der støtter Blazor Standalone, som fx Blazor Web App, der kræver en .NET server for at serve UI'en. Oven i hatten, så er Blazor som et front end framework, der ikke er afhængig af en bestemt form for server, ikke så populært som fx React, Angular og Vue. Derfor eksisterer der heller ikke dokumentation for Blazor Standalone, på lige fod med de Java Script baserede frameworks. På den ene side ville det have været meget nemmere, hvis jeg havde valgt Blazor Web App, hvor jeg bare kunne scaffolde eksempelvis, Docker og Identity i applikationen, så det havde virket på magisk vis, hvor at Client og Server spiller sammen fra start. På den anden side, så fik jeg lært noget om hvordan tingene fungere bag om det magiske tæppe. Lad os starte hårdt ud fra toppen Main Layout @using Microsoft.AspNetCore.Components.Routing @using MudBlazor @inherits LayoutComponentBase <MudThemeProvider /> <MudPopoverProvider /> <MudDialogProvider /> <MudSnackbarProvider /> <MudLayout> <MudAppBar Elevation=\"1\"> <AuthorizeView Roles=\"Admin\"> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Secondary\" OnClick=\"@ToggleDrawer\"> Admin</MudButton> </AuthorizeView> <MudNavLink Href=\"/\" Match=\"NavLinkMatch.All\"> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\"> Home</MudButton> </MudNavLink> <AuthorizeView Roles=\"Admin, Judge, DogHandler\"> <Authorized> <MudNavLink Href=\"/logout\" Match=\"NavLinkMatch.All\"> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\"> Logout</MudButton> </MudNavLink> </Authorized> <NotAuthorized> <MudNavLink Href=\"/login\"> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\"> Login</MudButton> </MudNavLink> </NotAuthorized> </AuthorizeView> </MudAppBar> <MudDrawer @bind-Open=\"@_open\" ClipMode=\"DrawerClipMode.Always\" Elevation=\"2\" Variant=\"@DrawerVariant.Temporary\" Color=\"Color.Primary\"> <MudDrawerHeader> <MudText Typo=\"Typo.h6\">Admin</MudText> </MudDrawerHeader> <MudNavMenu> <MudNavLink Match=\"NavLinkMatch.All\" Href=\"/admin/guide\" Icon=\"@Icons.Material.Filled.People\" IconColor=\"Color.Inherit\"> Admin Guide</MudNavLink> <MudNavLink Match=\"NavLinkMatch.All\" Href=\"/admin/users\" Icon=\"@Icons.Material.Filled.LocalLibrary\" IconColor=\"Color.Inherit\"> Manage Users</MudNavLink> <MudNavGroup Title=\"Edit Template\" Icon=@Icons.Material.Filled.AddModerator IconColor=\"Color.Inherit\" Expanded=\"false\"> <MudNavLink Match=\"NavLinkMatch.All\" Href=\"/admin/template\"> Rallyfield Templates</MudNavLink> <MudNavLink Match=\"NavLinkMatch.All\" Href=\"/admin/rallyfield-rules\"> Rallyfield Rules</MudNavLink> </MudNavGroup> <MudNavLink Match=\"NavLinkMatch.All\" Href=\"/admin/claims\" Icon=@Icons.Material.Filled.AddModerator IconColor=\"Color.Inherit\"> Claims</MudNavLink> </MudNavMenu> </MudDrawer> <MudMainContent> @Body </MudMainContent> </MudLayout> @code { private bool _open = false; private void ToggleDrawer() { _open = !_open; } } ExerciseForm.cs @inject ImageProcessingService ImageService @inject ExerciseService ExerciseService @inject TypeService TypeService @inject TempoService TempoService @inject ObstacleService ObstacleService; <MudForm Model=\"exercise\" @ref=\"form\" Validation=\"@(validator.ValidateValue)\" ValidationDelay=\"0\"> <MudTextField @bind-Value=\"exercise.Number\" For=\"@(() => exercise.Number)\" Immediate=\"true\" Label=\"Number\" Variant=\"Variant.Outlined\" Class=\"mx-4\" /> <MudTextField @bind-Value=\"exercise.Name\" For=\"@(() => exercise.Name)\" Immediate=\"true\" Label=\"Name*\" Variant=\"Variant.Outlined\" Class=\"mx-4\" /> <MudTextField @bind-Value=\"exercise.Description\" For=\"@(() => exercise.Description)\" Immediate=\"true\" Label=\"Description\" Lines=\"5\" Variant=\"Variant.Outlined\" Class=\"mx-4\" /> <MudField Class=\"ma-4\" Variant=\"Variant.Outlined\"> <MudText Typo=\"Typo.h6\" Class=\"ma-4\">Side Handling</MudText> <MudCheckBox @ref=\"LeftHandledCheckbox\" @bind-Value=\"exercise.PositionLeft\" For=\"@(() => exercise.PositionLeft)\" Label=\"Left\" Class=\"mx-4\" /> <MudCheckBox @ref=\"RightHandledCheckbox\" @bind-Value=\"exercise.PositionRight\" For=\"@(() => exercise.PositionRight)\" Label=\"Right\" Class=\"mx-4\" /> </MudField> <MudSelect @ref=\"levelSelect\" T=\"GetLevelTemplate\" @bind-Value=\"selectedLevel\" ToStringFunc=\"@(l => l.Name)\" Variant=\"Variant.Outlined\" MultiSelection=\"false\" Label=\"Select level\" Class=\"ma-4\"> @foreach (var level in levels) { <MudSelectItem T=\"GetLevelTemplate\" Value=\"@level\"> @level.Name </MudSelectItem> } </MudSelect> <MudSelect @ref=\"typeSelect\" @bind-SelectedValues=\"selectedTypes\" ToStringFunc=\"@(t => t.Name)\" Variant=\"Variant.Outlined\" MultiSelection=\"true\" Label=\"Select exercise types\" Class=\"ma-4\"> @foreach (var type in types) { <MudSelectItem T=\"GetTypeTemplate\" Value=\"@type\"> @type.Name </MudSelectItem> } </MudSelect> <MudSelect @ref=\"tempoSelect\" @bind-SelectedValues=\"selectedTempos\" ToStringFunc=\"@(t => t.Name)\" Variant=\"Variant.Outlined\" MultiSelection=\"true\" Label=\"Select exercise tempos\" Class=\"ma-4\"> @foreach (var tempo in tempos) { <MudSelectItem T=\"GetTempoTemplate\" Value=\"@tempo\"> @tempo.Name </MudSelectItem> } </MudSelect> <MudSelect @ref=\"obstacleSelect\" @bind-SelectedValues=\"selectedObstacles\" ToStringFunc=\"@(t => t.Name)\" Variant=\"Variant.Outlined\" MultiSelection=\"true\" Label=\"Select obstacles\" Class=\"ma-4\"> @foreach (var obstacle in obstacles) { <MudSelectItem T=\"GetObstacleTemplate\" Value=\"@obstacle\"> @obstacle.Name </MudSelectItem> } </MudSelect> <MudField Class=\"ma-4\" Variant=\"Variant.Outlined\"> <MudStack Class=\"pa-4\"> @if (!string.IsNullOrEmpty(b64)) { <MudImage Src=\"@b64\" Alt=\"Uploaded Image\" ObjectFit=\"ObjectFit.Contain\" Width=\"100\" /> } <MudFileUpload @ref=\"@imageUpload\" T=\"IBrowserFile\" @bind-Files=\"uploadedImage\" Accept=\".png, .jpg, .jpeg\" OnFilesChanged=\"UploadImageToFormAsync\" MaximumFileCount=\"1\"> <ActivatorContent> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\" StartIcon=\"@Icons.Material.Filled.CloudUpload\"> Upload image file </MudButton> </ActivatorContent> </MudFileUpload> </MudStack> </MudField> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\" Class=\"ml-auto\" OnClick=\"@(async () => await Submit())\"> Save </MudButton> </MudForm> @code { [Inject] ISnackbar snackbar { get; set; } MudForm form = new(); MudCheckBox<bool> LeftHandledCheckbox = new(); MudCheckBox<bool> RightHandledCheckbox = new(); MudSelect<GetLevelTemplate> levelSelect = new(); MudSelect<GetTypeTemplate> typeSelect = new(); MudSelect<GetTempoTemplate> tempoSelect = new(); MudSelect<GetObstacleTemplate> obstacleSelect = new(); IBrowserFile? uploadedImage; MudFileUpload<IBrowserFile>? imageUpload; string b64; CreateExerciseTemplate exercise = new(); CreateExerciseTemplateValidator validator = new(); GetLevelTemplate selectedLevel = new(); List<GetLevelTemplate> levels = []; IEnumerable<GetTypeTemplate> selectedTypes = []; public List<GetTypeTemplate> types = []; IEnumerable<GetTempoTemplate> selectedTempos = []; public List <GetTempoTemplate> tempos = []; IEnumerable<GetObstacleTemplate> selectedObstacles = []; public List<GetObstacleTemplate> obstacles = []; [Parameter] public EventCallback<GetExerciseTemplate> OnExerciseAdded { get; set; } public void LoadLevels(List<GetLevelTemplate> levels) { this.levels = levels; } public void LoadPartialTemplateData(List<GetLevelTemplate> levels, List<GetTypeTemplate> types, List<GetTempoTemplate> tempos, List<GetObstacleTemplate> obstacles) { this.levels = levels; this.types = types; this.tempos = tempos; this.obstacles = obstacles; //StateHasChanged(); } public void AddNewLevel(GetLevelTemplate level) { levels.Add(level); StateHasChanged(); } public void AddNewExerciseType(GetTypeTemplate type) { types.Add(type); StateHasChanged(); } public void AddNewExerciseTempo(GetTempoTemplate tempo) { tempos.Add(tempo); StateHasChanged(); } public void AddNewObstacle(GetObstacleTemplate obstacle) { obstacles.Add(obstacle); StateHasChanged(); } public void UpdateLevel(GetLevelTemplate updatedLevel) { var levelToRemove = levels.Find(t => t.Id == updatedLevel.Id); if (levelToRemove is not null) { levels.Remove(levelToRemove); levels.Add(updatedLevel); typeSelect.Clear(); StateHasChanged(); } else { snackbar.Add(\"Could not find type\", Severity.Error); Console.WriteLine(\"Could not find type to remove before update.\"); return; } } public void UpdateExerciseType(GetTypeTemplate updatedType) { var typeToRemove = types.Find(t => t.Id == updatedType.Id); if (typeToRemove is not null) { types.Remove(typeToRemove); types.Add(updatedType); typeSelect.Clear(); StateHasChanged(); } else { snackbar.Add(\"Could not find type\", Severity.Error); Console.WriteLine(\"Could not find type to remove before update.\"); return; } } public void UpdateExerciseTempo(GetTempoTemplate updatedTempo) { var tempoToRemove = tempos.Find(t => t.Id == updatedTempo.Id); if (tempoToRemove is not null) { tempos.Remove(tempoToRemove); tempos.Add(updatedTempo); tempoSelect.Clear(); StateHasChanged(); } else { snackbar.Add(\"Could not find tempo\", Severity.Error); Console.WriteLine(\"Could not find tempo to remove before update.\"); return; } } public void UpdateObstacle(GetObstacleTemplate updatedObstacle) { var obstacleToRemove = obstacles.Find(t => t.Id == updatedObstacle.Id); if (obstacleToRemove is not null) { obstacles.Remove(obstacleToRemove); obstacles.Add(updatedObstacle); obstacleSelect.Clear(); StateHasChanged(); } else { snackbar.Add(\"Could not find type\", Severity.Error); Console.WriteLine(\"Could not find type to remove before update.\"); return; } } public void RemoveExerciseTypeTemplate(GetTypeTemplate type) { types.Remove(type); typeSelect.Clear(); StateHasChanged(); } public void RemoveTempoTemplate(GetTempoTemplate tempo) { tempos.Remove(tempo); tempoSelect.Clear(); StateHasChanged(); } public void RemoveObstacle(GetObstacleTemplate obstacle) { obstacles.Remove(obstacle); obstacleSelect.Clear(); StateHasChanged(); } async Task Submit() { await form.Validate(); if (!form.IsValid) { snackbar.Add(\"Invalid form\", Severity.Error); return; } try { var createdExercise = await ExerciseService.CreateExerciseAsync(exercise, selectedLevel, selectedTypes, selectedTempos, selectedObstacles, uploadedImage); await form.ResetAsync(); exercise.PositionLeft = false; exercise.PositionRight = false; await imageUpload.ClearAsync(); b64 = string.Empty; await typeSelect.Clear(); await tempoSelect.Clear(); await obstacleSelect.Clear(); await OnExerciseAdded.InvokeAsync(createdExercise); snackbar.Add(\"Exercise succesfully Saved.\", Severity.Success); } catch (HttpRequestException ex) { snackbar.Add(\"An error occurred while saving. Please check your network connection.\", Severity.Error); Console.WriteLine($\"HTTP error: {ex.Message}\"); } catch (InvalidOperationException ex) { snackbar.Add(\"An error occurred while processing the response from the server.\", Severity.Error); Console.WriteLine($\"Invalid operation: {ex.Message}\"); } catch (Exception ex) { snackbar.Add(\"An unexpected error occurred while saving the exercice template.\", Severity.Error); Console.WriteLine($\"Unexpected error: {ex.Message}\"); } } async Task UploadImageToFormAsync() { var fileSizeBytes = uploadedImage.Size; try { // Log the initial file size Console.WriteLine($\"Initial file size: {fileSizeBytes} bytes\"); if (fileSizeBytes >= 512000) // Max size for Base64 conversion { Console.WriteLine($\"File size exceeds {512000 / 1024 / 1024:F2} MB limit\"); snackbar.Add(\"Max file size for Base64 conversion is 0.5 MB\", Severity.Warning); } b64 = await ImageService.ConvertToBase64Async(uploadedImage); } catch (Exception ex) { Console.WriteLine($\"Error during upload: {ex.Message}\"); snackbar.Add(\"An error occurred doing image upload\", Severity.Error); } } } De forskellige dele af en exercise, består af mindre dele som en bruger har valgt i de forudgående forms. Jeg har samlet variablerne i LoadPartialTemplateData() som argumenter, for at kunne samle dem, og lavet den public, så den kan modtage data fra andre steder i applikationen og opdatere komponenten. FluentValidation .NET bibliotek for validering. Det er et meget populært og udbredt, men Blazor understøtter det ikke direkte, da det primært er for Server side. Da en af hovedårsagerne til at jeg valgte Blazor til min .NET API, var at jeg kunne bruge C# klasser eller records til DTO's, så jeg kunne bruge de samme objekter i både front og backend. Ved at bruge de samme objekter til at transportere data mellem front og backend, kan jeg bruge den samme validerings kode i begge ender, i stedet for at holde styr på validering begge steder, eller droppe validering i front end, da det ville være nemmere at holde styr på og det vigtigste at sikre er serveren. Med MudBlazor kan jeg bruge Fluent validation i mine DTO's og bruge de DTO's i både Blazor components og i mine endpoints og dermed nå frem til den samme validering i både front- og backend. CreateExerciseTemplate exercise som er den model jeg bruger for exerciseTemplate formen er en implementering af CreateExerciseTemplate. validator er en implementering af CreateExerciseTemplateValidator der validerer CreateExerciseTemplate namespace DogObedience.Shared.Admin.Templates.ExerciseTemplate; public class CreateExerciseTemplate { public bool IsTemplate { get; set; } = true; public int Number { get; set; } public string Name { get; set; } = string.Empty; public string Description { get; set; } = string.Empty; public bool PositionLeft { get; set; } public bool PositionRight { get; set; } public string Color { get; set; } = string.Empty; public int LevelId { get; set; } public ICollection<CreateTypeTemplate> Types { get; set; } = []; public ICollection<CreateTempoTemplate> Tempos { get; set; } = []; public ICollection<CreateObstacleTemplate> Obstacles { get; set; } = []; public IFormFile? ImageFile { get; set; } } public class CreateExerciseTemplateValidator : AbstractValidator<CreateExerciseTemplate> { public CreateExerciseTemplateValidator() { RuleFor(x => x.Number).NotEmpty(); RuleFor(x => x.Name).NotEmpty(); RuleFor(x => x.Description).NotEmpty(); RuleFor(x => x.ImageFile.Length).LessThanOrEqualTo(512000); // Max size for Base64 conversion RuleFor(x => x.Types).NotEmpty(); RuleFor(x => x.Tempos).NotEmpty(); RuleFor(x => x.Obstacles).NotEmpty(); } public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) => { var result = await ValidateAsync(ValidationContext<CreateExerciseTemplate>.CreateWithOptions((CreateExerciseTemplate)model, x => x.IncludeProperties(propertyName))); if (result.IsValid) return Array.Empty<string>(); return result.Errors.Select(e => e.ErrorMessage); }; } ExerciseDataGrid Er af tilsvarende kompleksitet som ExerciseForm @inject ExerciseService ExerciseService @inject TypeService TypeService @inject TempoService TempoService @inject ObstacleService ObstacleService; @inject ImageProcessingService ImageService @if (exercises == null || exercises.Count() == 0) { <p>No exercise created yet.</p> } <MudDataGrid T=\"GetExerciseTemplate\" Items=\"@exercises\" ReadOnly=\"@false\" EditMode=\"@DataGridEditMode.Form\" Bordered=\"true\" Dense=\"true\" Hover=\"true\" EditTrigger=\"@DataGridEditTrigger.OnRowClick\" CommittedItemChanges=\"@CommittedItemChanges\"> <Columns> <PropertyColumn Property=\"x => x.Number\" /> <PropertyColumn Property=\"x => x.Name\" /> <PropertyColumn Property=\"x => x.Description\" /> <PropertyColumn Property=\"x => x.Types\"> <EditTemplate> <MudSelect T=\"GetTypeTemplate\" @bind-SelectedValues=\"@context.Item.Types\" ToStringFunc=\"@(t => t.Name)\" MultiSelection=\"true\"> @foreach (var type in types) { <MudSelectItem T=\"GetTypeTemplate\"> @type.Name </MudSelectItem> } </MudSelect> </EditTemplate> <CellTemplate> @string.Join(\", \", context.Item.Types.Select(x => x.Name)) </CellTemplate> </PropertyColumn> <PropertyColumn Property=\"x => x.Tempos\"> <EditTemplate> <MudSelect T=\"GetTempoTemplate\" @bind-SelectedValues=\"@context.Item.Tempos\" ToStringFunc=\"@(t => t.Name)\" MultiSelection=\"true\"> @foreach (var tempo in tempos) { <MudSelectItem T=\"GetTempoTemplate\"> @tempo.Name </MudSelectItem> } </MudSelect> </EditTemplate> <CellTemplate> @string.Join(\", \", context.Item.Tempos.Select(x => x.Name)) </CellTemplate> </PropertyColumn> <PropertyColumn Property=\"x => x.PositionLeft\" Title=\"Left Handled\"> <EditTemplate> <MudCheckBox @bind-Value=\"context.Item.PositionLeft\" Label=\"Left\"/> </EditTemplate> </PropertyColumn> <PropertyColumn Property=\"x => x.PositionRight\" Title=\"Right Handled\"> <EditTemplate> <MudCheckBox @bind-Value=\"context.Item.PositionRight\" Label=\"Right\"/> </EditTemplate> </PropertyColumn> <PropertyColumn Property=\"x => x.Obstacles\"> <EditTemplate> <MudSelect T=\"GetObstacleTemplate\" @bind-SelectedValues=\"@context.Item.Obstacles\" ToStringFunc=\"@(o => o.Name)\" MultiSelection=\"false\"> @foreach (var obstacle in obstacles) { <MudSelectItem T=\"GetObstacleTemplate\"> @obstacle.Name </MudSelectItem> } </MudSelect> </EditTemplate> <CellTemplate> <MudStack Row=\"true\" Class=\"d-flex align-center\"> <MudText>@string.Join(\", \", context.Item.Obstacles.Select(x => x.Name))</MudText> @if (context.Item.B64 is not null) { <MudImage Src=\"@context.Item.B64\" Alt=\"Exercise Image\" ObjectFit=\"ObjectFit.Contain\" Width=\"100\" /> } else { <p>No image available</p> } </MudStack> </CellTemplate> </PropertyColumn> <PropertyColumn Property=\"x => x.ImageFile\" Title=\"Image\"> <EditTemplate> <MudFileUpload @ref=\"@imageUpload\" T=\"IBrowserFile\" @bind-Files=\"@context.Item.ImageFile\" Accept=\".png, .jpg, .jpeg\" OnFilesChanged=\"async (e) => await UploadImageToDataGridAsync(context.Item.ImageFile)\" MaximumFileCount=\"1\"> <ActivatorContent> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\" StartIcon=\"@Icons.Material.Filled.CloudUpload\"> Upload image file </MudButton> </ActivatorContent> </MudFileUpload> </EditTemplate> <CellTemplate> @if (context.Item.B64 is not null) { <MudImage Src=\"@context.Item.B64\" Alt=\"Exercise Image\" ObjectFit=\"ObjectFit.Contain\" Width=\"100\" /> } else { <p>No image available</p> } </CellTemplate> </PropertyColumn> <TemplateColumn CellClass=\"d-flex justify-end\"> <CellTemplate> <MudIconButton Size=\"@Size.Medium\" Icon=\"@Icons.Material.Filled.Delete\" Color=\"Color.Error\" OnClick=\"async (e) => await DeleteExerciseAsync(context.Item.Id)\" /> </CellTemplate> </TemplateColumn> </Columns> </MudDataGrid> @code { [Inject] ISnackbar snackbar { get; set; } string dataGridB64 = string.Empty; IBrowserFile image; MudFileUpload<IBrowserFile> imageUpload; List<GetLevelTemplate> levels = []; List<GetExerciseTemplate> exercises = []; List<GetTypeTemplate> types = []; List<GetTempoTemplate> tempos = []; List<GetObstacleTemplate> obstacles = []; public void LoadExerciseTemplates(List<GetExerciseTemplate> exercises) { this.exercises = exercises; StateHasChanged(); } public void LoadPartialTemplateData(List<GetLevelTemplate> levels, List<GetTypeTemplate> types, List<GetTempoTemplate> tempos, List<GetObstacleTemplate> obstacles) { this.levels = levels; this.types = types; this.tempos = tempos; this.obstacles = obstacles; StateHasChanged(); } public void AddNewExercise(GetExerciseTemplate newExerciseType) { exercises.Add(newExerciseType); StateHasChanged(); } async Task CommittedItemChanges(GetExerciseTemplate exercise) { try { var updatedExercise = await ExerciseService.UpdateExerciseTemplateAsync(exercise); var exerciseToRemove = exercises.Find(e => e.Id == exercise.Id); if(exercise is not null) { exercises.Remove(exerciseToRemove); exercises.Add(updatedExercise); } StateHasChanged(); snackbar.Add(\"Exercise succesfully updated\", Severity.Success); } catch (HttpRequestException ex) { snackbar.Add(\"An error occurred while saving. Please check your network connection.\", Severity.Error); Console.WriteLine($\"HTTP error: {ex.Message}\"); } catch (InvalidOperationException ex) { snackbar.Add(\"An error occurred while processing the response from the server.\", Severity.Error); Console.WriteLine($\"Invalid operation: {ex.Message}\"); } catch (Exception ex) { snackbar.Add(\"An unexpected error occurred while updating exercise template.\", Severity.Error); Console.WriteLine($\"Unexpected error: {ex.Message}\"); } } async Task DeleteExerciseAsync(int? id) { try { await ExerciseService.DeleteExerciseTemplateAsync(id); var exerciseToRemove = exercises.Find(p => p.Id == id); if (exerciseToRemove is not null) { exercises.Remove(exerciseToRemove); snackbar.Add(\"Exercise template successfully deleted.\", Severity.Success); } else { snackbar.Add(\"No exercise template found with the given ID.\", Severity.Warning); } } catch (HttpRequestException ex) { snackbar.Add(\"An error occurred while saving. Please check your network connection.\", Severity.Error); Console.WriteLine($\"HTTP error: {ex.Message}\"); } catch (InvalidOperationException ex) { snackbar.Add(\"An error occurred while processing the response from the server.\", Severity.Error); Console.WriteLine($\"Invalid operation: {ex.Message}\"); } catch (Exception ex) { snackbar.Add(\"An unexpected error occurred while deleting exercise templates.\", Severity.Error); Console.WriteLine($\"Unexpected error: {ex.Message}\"); } } async Task UploadImageToDataGridAsync(IBrowserFile image) => dataGridB64 = await ImageService.ConvertToBase64Async(image); } ExerciseService Har ansvaret for at send og modtage data fra Serveren. Da jeg ikke kunne sende en fil som en del af et C# object, men stadig skulle sende 1 object til serveren, endte det med at jeg måtte bruge et multipartformdatacontent og så mappe hver property til en navngiven multipartformdata property. Jeg skulle så samtidig sørge for at det endpoint jeg sender multipartformdata objektet til, er sat op så at det kan modtage et objekt der har de samme property navne og variabler. Hovedårsagen til denne kompleksitet er at man ikke kan stole på hvad som bliver uploaded på Client side. Havde koden været på serveren, havde den været mere sikker, og jeg ville kunne scanne den for virus og sende den direkte til en database eller et blob storage. namespace DogObedience.Client.Features.Admin.Templates.ExerciseTemplate; public class ExerciseService { private readonly HttpClient _httpClient; private readonly ImageProcessingService _imageProcessingService; public ExerciseService(HttpClient httpClient, ImageProcessingService imageProcessingService) { _httpClient = httpClient; _imageProcessingService = imageProcessingService; } public async Task<GetExerciseTemplate> CreateExerciseAsync( CreateExerciseTemplate exercise, GetLevelTemplate selectedLevel, IEnumerable<GetTypeTemplate> selectedTypes, IEnumerable<GetTempoTemplate> selectedTempos, IEnumerable<GetObstacleTemplate> selectedObstacles, IBrowserFile imageFile) { try { var content = new MultipartFormDataContent { // Exercise template data { new StringContent(exercise.Number.ToString()), \"Number\" }, { new StringContent(exercise.Name), \"Name\" }, { new StringContent(exercise.Description), \"Description\" }, { new StringContent(exercise.PositionLeft.ToString()), \"PositionLeft\" }, { new StringContent(exercise.PositionRight.ToString()), \"PositionRight\" }, // Level template data { new StringContent(selectedLevel.Id.ToString()), \"LevelId\" }, { new StringContent(selectedLevel.Name), \"Level.Name\" }, { new StringContent(selectedLevel.Color), \"Color\" }, }; // Types int typeIndex = 0; foreach (var type in selectedTypes) { content.Add(new StringContent(type.IsTemplate.ToString()), $\"Types[{typeIndex}].IsTemplate\"); content.Add(new StringContent(type.Name), $\"Types[{typeIndex}].Name\"); typeIndex++; } // Tempos int tempoIndex = 0; foreach (var tempo in selectedTempos) { content.Add(new StringContent(tempo.IsTemplate.ToString()), $\"Tempos[{tempoIndex}].IsTemplate\"); content.Add(new StringContent(tempo.Name), $\"Tempos[{tempoIndex}].Name\"); tempoIndex++; } // Obstacles int obstacleIndex = 0; foreach (var obstacle in selectedObstacles) { content.Add(new StringContent(obstacle.IsTemplate.ToString()), $\"Obstacles[{obstacleIndex}].IsTemplate\"); content.Add(new StringContent(obstacle.Name), $\"Obstacles[{obstacleIndex}].Name\"); content.Add(new StringContent(obstacle.B64), $\"Obstacles[{obstacleIndex}].B64\"); obstacleIndex++; } // ImageFile await using var fileStream = imageFile.OpenReadStream(); using var streamContent = new StreamContent(fileStream); streamContent.Headers.ContentType = new MediaTypeHeaderValue(imageFile.ContentType); content.Add(streamContent, \"ImageFile\", imageFile.Name); var response = await _httpClient.PostAsync(\"api/admin/field-template/level-template/exercise-template\", content); if (!response.IsSuccessStatusCode) { var errorContent = await response.Content.ReadAsStringAsync(); throw new HttpRequestException($\"Request failed with status code {response.StatusCode}: {errorContent}\"); } var createdExercise = await response.Content.ReadFromJsonAsync<GetExerciseTemplate>(); if (createdExercise is not null) { return createdExercise; } throw new InvalidOperationException(\"Failed to deserialize the response content.\"); } catch (HttpRequestException ex) { Console.WriteLine($\"An HTTP error occurred: {ex.Message}\"); throw; } catch (Exception ex) { Console.WriteLine($\"An unexpected error occurred: {ex.Message}\"); throw; } } public async Task<List<GetExerciseTemplate>> GetExerciseTemplatesAsync() { try { var response = await _httpClient.GetAsync(\"api/admin/field-template/level-template/exercise-template\"); if (!response.IsSuccessStatusCode) { if (response.StatusCode == HttpStatusCode.NotFound) return []; var errorContent = await response.Content.ReadAsStringAsync(); throw new HttpRequestException($\"Request failed with status code {response.StatusCode}: {errorContent}\"); } var exercises = await response.Content.ReadFromJsonAsync<List<GetExerciseTemplate>>(); if (exercises is not null) { return exercises; } throw new InvalidOperationException(\"Failed to deserialize the response content.\"); } catch (HttpRequestException ex) { Console.WriteLine($\"An HTTP error occurred: {ex.Message}\"); throw; } catch (Exception ex) { Console.WriteLine($\"An unexpected error occurred: {ex.Message}\"); throw; } } public async Task<GetExerciseTemplate> UpdateExerciseTemplateAsync(GetExerciseTemplate exercise) { if (exercise == null) throw new ArgumentNullException(nameof(exercise), \"Exercise cannot be null.\"); if (exercise.Level == null) throw new ArgumentNullException(nameof(exercise.Level), \"Exercise.Level cannot be null.\"); try { var content = new MultipartFormDataContent { // Exercise template data { new StringContent(exercise.Id.ToString()), \"Id\" }, { new StringContent(exercise.IsTemplate.ToString()), \"IsTemplate\" }, { new StringContent(exercise.Number.ToString()), \"Number\" }, { new StringContent(exercise.Name), \"Name\" }, { new StringContent(exercise.Description), \"Description\" }, { new StringContent(exercise.PositionLeft.ToString()), \"PositionLeft\" }, { new StringContent(exercise.PositionRight.ToString()), \"PositionRight\" }, { new StringContent(exercise.B64), \"B64\" }, // Level template data { new StringContent(exercise.LevelId.ToString()), \"LevelId\" }, { new StringContent(exercise.Level.Name), \"Level.Name\" }, { new StringContent(exercise.Level.Color), \"Level.Color\" } }; // Types int typeIndex = 0; foreach (var type in exercise.Types) { content.Add(new StringContent(type.Id.ToString()), $\"Types[{typeIndex}].Id\"); content.Add(new StringContent(type.IsTemplate.ToString()), $\"Types[{typeIndex}].IsTemplate\"); content.Add(new StringContent(type.Name), $\"Types[{typeIndex}].Name\"); typeIndex++; } // Tempos int tempoIndex = 0; foreach (var tempo in exercise.Tempos) { content.Add(new StringContent(tempo.Id.ToString()), $\"Tempos[{tempoIndex}].Id\"); content.Add(new StringContent(tempo.IsTemplate.ToString()), $\"Tempos[{tempoIndex}].IsTemplate\"); content.Add(new StringContent(tempo.Name), $\"Tempos[{tempoIndex}].Name\"); tempoIndex++; } // Obstacles int obstacleIndex = 0; foreach (var obstacle in exercise.Obstacles) { content.Add(new StringContent(obstacle.Id.ToString()), $\"Obstacles[{obstacleIndex}].Id\"); content.Add(new StringContent(obstacle.IsTemplate.ToString()), $\"Obstacles[{obstacleIndex}].IsTemplate\"); content.Add(new StringContent(obstacle.Name), $\"Obstacles[{obstacleIndex}].Name\"); if (exercise.ImageFile is not null) { var b64 = await _imageProcessingService.ConvertToBase64Async(exercise.ImageFile); content.Add(new StringContent(b64), $\"Obstacles[{obstacleIndex}].B64\"); } else { content.Add(new StringContent(exercise.B64), $\"Obstacles[{obstacleIndex}].B64\"); } obstacleIndex++; } var response = await _httpClient.PutAsync($\"api/admin/field-template/level-template/exercise-template/{exercise.Id}\", content); if (!response.IsSuccessStatusCode) { var errorContent = await response.Content.ReadAsStringAsync(); throw new HttpRequestException($\"Request failed with status code {response.StatusCode}: {errorContent}\"); } var updatedExercise = await response.Content.ReadFromJsonAsync<GetExerciseTemplate>(); if (updatedExercise is not null) { return updatedExercise; } throw new InvalidOperationException(\"Failed to deserialize the response content.\"); } catch (HttpRequestException ex) { Console.WriteLine($\"An HTTP error occurred: {ex.Message}\"); throw; } catch (Exception ex) { Console.WriteLine($\"An unexpected error occurred: {ex.Message}\"); throw; } } public async Task DeleteExerciseTemplateAsync(int? id) { if (id is null) { throw new ArgumentNullException(nameof(id), \"ID cannot be null\"); } try { var response = await _httpClient.DeleteAsync($\"api/admin/field-template/level-template/exercise-template/{id}\"); if (!response.IsSuccessStatusCode) { var errorContent = await response.Content.ReadAsStringAsync(); throw new HttpRequestException($\"Request failed with status code {response.StatusCode}: {errorContent}\"); } } catch (HttpRequestException ex) { Console.WriteLine($\"An HTTP error occurred: {ex.Message}\"); throw; } catch (Exception ex) { Console.WriteLine($\"An unexpected error occurred: {ex.Message}\"); throw; } } }"
  },
  "implementering/docker.html": {
    "href": "implementering/docker.html",
    "title": "Docker | dadaPipes",
    "keywords": "Docker Det endte med at jeg gav op på at Containerize min applikation. Det var lykkedes for mig med en prototype, men der findes ingen muligheder for at komme nemt fra start, eller noget dokumentation for hvordan at man gør. Endnu en årsag til at jeg vil vælge en anden form for serverless frontend, hvis det skulle være et krav. Scaffold docker i .NET Web API Højreklik på server projektet klik på Docker support.. Vælg dette Container OS: Linux Container Build Type: Dockerfile Container Image Distro: Default (8) Docker Build Context: ... Det scaffolder 'Dockerfile' i roden af folderen og ser sådan her ud: # See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging. # This stage is used when running from VS in fast mode (Default for Debug configuration) FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base USER $APP_UID WORKDIR /app EXPOSE 8080 EXPOSE 8081 # This stage is used to build the service project FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build ARG BUILD_CONFIGURATION=Release WORKDIR /src COPY [\"DogObedience.Server/DogObedience.Server.csproj\", \"DogObedience.Server/\"] COPY [\"DogObedience.Client/DogObedience.Client.csproj\", \"DogObedience.Client/\"] COPY [\"DogObedience.Shared/DogObedience.Shared.csproj\", \"DogObedience.Shared/\"] RUN dotnet restore \"./DogObedience.Server/DogObedience.Server.csproj\" COPY . . WORKDIR \"/src/DogObedience.Server\" RUN dotnet build \"./DogObedience.Server.csproj\" -c $BUILD_CONFIGURATION -o /app/build # This stage is used to publish the service project to be copied to the final stage FROM build AS publish ARG BUILD_CONFIGURATION=Release RUN dotnet publish \"./DogObedience.Server.csproj\" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false # This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration) FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\"dotnet\", \"DogObedience.Server.dll\"] Ovenstående fil er ikke helt korrekt, da jeg gerne vil hoste mit Server og Client projekt hver for sig. Derfor skal de selfølgelig have hver deres container. Client projektet fjernes og jeg saniterer det en smule, så det er nemmere at se hvad der sker. Server og Shared projekterne beholdes. Server, fordi at det er det vi gerne vil containorize, og Shared fordi at det bliver brugt i Server projektet og gerne skulle hostes sammen: # Use the ASP.NET Core runtime as the base image FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base WORKDIR /app EXPOSE 8080 # Use the .NET SDK to build the project FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build ARG BUILD_CONFIGURATION=Release WORKDIR /src # Copy and restore dependencies COPY ./DogObedience.Shared/ /src/DogObedience.Shared/ COPY ./DogObedience.Server/DogObedience.Server.csproj ./DogObedience.Server/ WORKDIR /src/DogObedience.Server RUN dotnet restore \"./DogObedience.Server.csproj\" # Copy the entire source and build COPY ./DogObedience.Server/. ./ RUN dotnet build \"./DogObedience.Server.csproj\" -c $BUILD_CONFIGURATION -o /app/build # Publish the app in a separate stage FROM build AS publish ARG BUILD_CONFIGURATION=Release RUN dotnet publish \"./DogObedience.Server.csproj\" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false # Final stage: Run the application FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\"dotnet\", \"DogObedience.Server.dll\"] Nu er det tid til at containorize Client projeket: Tilføj en fil i roden af klient projektet. Lav en .txt fil, giv det navnet Dockerfile og slet .txt efterfølgende Tilføj en fil i roden af klient projektet. giv det navnet nginx.conf nginx er en web server og den har vi brug for, for at kunne serve HTML, CSS og Java Script, i Standalone. Hvis jeg ikke har nævnt det noget andet sted i bloggen, så er Blazor Standalone et serverless framework. Det vil sige at den ikke er afhængig af en .NET server til at 'serve' HTML, CSS og Java Script. Derfor skal der en server til for at kunne 'serve' det. events { } http { include mime.types; types { application/wasm wasm; } server { listen 80; index index.html; location / { root /usr/share/nginx/html; try_files $uri $uri/ /index.html =404; } } } Dockerfile i Client projektet: # Build Stage FROM mcr.microsoft.com/dotnet/sdk:8.0-alpine AS build-env WORKDIR /app # Copy the client and shared .csproj files and restore dependencies COPY ./DogObedience.Client/DogObedience.Client.csproj ./DogObedience.Client/ COPY ./DogObedience.Shared/DogObedience.Shared.csproj ./DogObedience.Shared/ RUN dotnet restore \"./DogObedience.Client/DogObedience.Client.csproj\" # Copy the rest of the client and shared project files COPY ./DogObedience.Client/ ./DogObedience.Client/ COPY ./DogObedience.Shared/ ./DogObedience.Shared/ # Publish the client project WORKDIR /app/DogObedience.Client RUN dotnet publish -c Release -o output # Nginx Stage FROM nginx:alpine WORKDIR /usr/share/nginx/html # Copy the published output to the Nginx HTML folder COPY --from=build-env /app/DogObedience.Client/output/wwwroot . # Specify the path for nginx.conf from the context directory COPY ./DogObedience.Client/nginx.conf /etc/nginx/nginx.conf # Expose port 80 for the client EXPOSE 80 Så er det tid til Docker-compose, så jeg kan orkestrerer containerne. Højre klik på Server projektet => Add => Container Orchestrator Support => OK => OK Det giver 3 filer: .dockerignore Den lader vi stå som den er launchSettings.json Så jeg kan trykke på den grønne pil i VS 2022 og spinne containerne op, uden at bruge CLI'en. { \"profiles\": { \"Docker Compose\": { \"commandName\": \"DockerCompose\", \"commandVersion\": \"1.0\", \"serviceActions\": { \"fastrallyobedience.server\": \"StartDebugging\" } } } } Docker-compose Den fil der får det hele til at spille sammen, så man kun behøver at køre 1 fil for at få containerne op at spinde. Important context . Servicene tager udgangspunkt i root af solution. Det tog mig pinligt lang tid at finde ud af hvorfor at jeg ikke kunne få det til at virke. Hvis ikke at man sætter udgangspunktet til *root så skal man huske på at docker-compose.yml filen, i dette tilfælde er placeret inde i docker-compose folderen. services: DogObedience.server: build: context: . dockerfile: ./DogObedience.Server/Dockerfile ports: - \"8080:8080\" # HTTP depends_on: - sqlserver sqlserver: image: mcr.microsoft.com/mssql/server:2022-latest environment: MSSQL_SA_PASSWORD: \"myStrong_Password123#\" ACCEPT_EULA: \"Y\" ports: - \"1433:1433\" DogObedience.client: build: context: . dockerfile: ./DogObedience.Client/Dockerfile ports: - \"80:80\" Client, Server og en SQLServer er de containere jeg gerne skal have op at køre. Når jeg bruger kommandoen docker-compose up --build ser det umiddelbart ud til at fungere, men jeg har glemt en ting: Microsoft.Data.SqlClient.SqlException (0x80131904): A network-related or instance-specific error occurred while establishing a connection to SQL Server. The server was not found or was not accessible."
  },
  "implementering/server.html": {
    "href": "implementering/server.html",
    "title": "Server | dadaPipes",
    "keywords": "Server Controller CreateExerciseTemplate og UpdateExerciseTemplate er begge de samme objekter som er brugt i Blazor komponenterne. Det vil sige at de har den samme validering. Hvis der skulle være en ondsindet bruger der forsøger sig med at sende korupt data ned til serveren, Fx 150% rabat, så får brugeren ikke penge tilbage, hver gang at de køber noget. Nu er dette ikke en online shop, men ideen er den samme. Vi vil kun have saniteret data ned til vores server, hvor de basekyttede dele af forretings logikken ligger. Det er ikke altid at det er nok at sanitere data ved kun at lade bestemte typer af data med bestemte navne få adgang. Filer kan gå hen og være et et våben, som kryptonit er for Superman. Man ved aldrig hvad der gemmer sig, uanset hvad file typen er, da det kan spoofes. Det har ikke været et særligt højt krav, og har derfor ikke haft et så stort fokus, da det er meget få og betroede brugere der kommer til at have adgang til at uploade filer. Derfor er det ikke noget der er blevet implementeret. Man kan bruge data annotations til at få ASP.NET Core til at lave json output som kan bruges af biblioteker som Swagger til at lave testbar dokumentation. Eksemplet herunder vil dokumentere at enpointed kan give en Status code 400 BadRequest. [ProducesResponseType(StatusCodes.Status400BadRequest)] Hvad jeg så fandt ud af senere hen var at det var fuldstændigt unødigt, da de kan dokumentere sig selv med web API conventions. Så sparer man da de linier kode. namespace DogObedience.Server.Features.Admin.Templates.ExerciseTemplate; [ApiExplorerSettings(GroupName = \"admin/templates\")] [Authorize(Roles = \"Admin\")] [Route(\"api/admin/field-template/level-template/exercise-template\")] [ApiController] public class ExerciseController : ControllerBase { private readonly ExerciseService _exerciseService; public ExerciseController(ExerciseService service) { _exerciseService = service; } [HttpPost] [ProducesResponseType(StatusCodes.Status201Created, Type = typeof(GetExerciseTemplate))] [ProducesResponseType(StatusCodes.Status400BadRequest)] public async Task<IActionResult> CreateExerciseTemplate([FromForm] CreateExerciseTemplate exercise) { var result = await _exerciseService.CreateExerciseTemplateAsync(exercise); return StatusCode(201, result.Value); } [HttpGet] [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(List<GetExerciseTemplate>))] [ProducesResponseType(StatusCodes.Status204NoContent)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public async Task<IActionResult> GetAllExerciseTemplates() { var result = await _exerciseService.GetAllExerciseTemplatesAsync(); if (result.IsFailed) return NotFound(result.Errors); return Ok(result.Value); } [HttpPut(\"{id}\")] public async Task<IActionResult> UpdateExerciseTemplate(int id, [FromForm] UpdateExerciseTemplate exercise) { var updatedExercise = await _exerciseService.UpdateExerciseTemplate(id, exercise); return Ok(updatedExercise); } [HttpDelete(\"{id}\")] [ProducesResponseType(StatusCodes.Status204NoContent)] [ProducesResponseType(StatusCodes.Status400BadRequest)] [ProducesResponseType(StatusCodes.Status404NotFound)] public async Task<IActionResult> DeleteExerciseTemplate(int id) { var result = await _exerciseService.DeleteExerciseTemplate(id); if (result.IsFailed) return NotFound(result.Errors); return NoContent(); } } Service public async Task<GetExerciseTemplate> UpdateExerciseTemplate(int dtoId, UpdateExerciseTemplate exerciseToUpdate) { var existingExercise = await _context.Exercises .Include(e => e.Tempos) .Include(e => e.Level) .Include(e => e.Types) .Include(e => e.Obstacles) .FirstOrDefaultAsync(e => e.Id == dtoId) ?? throw new Exception(\"Exercise template not found.\"); // Update basic properties of the exercise _context.Entry(existingExercise).CurrentValues.SetValues(exerciseToUpdate); // Update the LevelId if (exerciseToUpdate.LevelId != 0) { var existingLevel = await _context.Levels.FirstOrDefaultAsync(l => l.Id == exerciseToUpdate.LevelId) ?? throw new Exception(\"Level not found.\"); existingExercise.LevelId = existingLevel.Id; } // Update Types var typesToRemove = existingExercise.Types .Where(existingType => exerciseToUpdate.Types.All(t => t.Id != existingType.Id)) .ToList(); _context.ExerciseTypes.RemoveRange(typesToRemove); foreach (var type in exerciseToUpdate.Types) { var existingType = existingExercise.Types.FirstOrDefault(et => et.Id == type.Id); if (existingType != null) { _context.Entry(existingType).CurrentValues.SetValues(type); } else { existingExercise.Types.Add(new ExerciseType { Name = type.Name, IsTemplate = type.IsTemplate, ExerciseId = dtoId // Set foreign key }); } } // Update Tempos var temposToRemove = existingExercise.Tempos .Where(existingTempo => exerciseToUpdate.Tempos.All(t => t.Id != existingTempo.Id)) .ToList(); _context.ExerciseTempos.RemoveRange(temposToRemove); foreach (var tempo in exerciseToUpdate.Tempos) { var existingTempo = existingExercise.Tempos.FirstOrDefault(et => et.Id == tempo.Id); if (existingTempo != null) { _context.Entry(existingTempo).CurrentValues.SetValues(tempo); } else { existingExercise.Tempos.Add(new ExerciseTempo { Name = tempo.Name, IsTemplate = tempo.IsTemplate, ExerciseId = dtoId // Set foreign key }); } } // Update Obstacles var obstaclesToRemove = existingExercise.Obstacles .Where(existingObstacle => exerciseToUpdate.Obstacles.All(o => o.Id != existingObstacle.Id)) .ToList(); _context.Obstacles.RemoveRange(obstaclesToRemove); foreach (var obstacle in exerciseToUpdate.Obstacles) { var existingObstacle = existingExercise.Obstacles.FirstOrDefault(o => o.Id == obstacle.Id); if (existingObstacle != null) { _context.Entry(existingObstacle).CurrentValues.SetValues(obstacle); } else { existingExercise.Obstacles.Add(new Obstacle { Name = obstacle.Name, IsTemplate = obstacle.IsTemplate, B64 = obstacle.B64, ExerciseId = dtoId // Set foreign key }); } } // Save changes to the database await _context.SaveChangesAsync(); // Map the updated exercise to the DTO and return var updatedExercise = _map.ToGetExercise(existingExercise); return updatedExercise; } async Task<string> ConvertToB64(IFormFile image) { await using var ms = new MemoryStream(); await image.CopyToAsync(ms); var bytes = ms.ToArray(); var b64 = Convert.ToBase64String(bytes); return $\"data:{image.ContentType};base64,{b64}\"; } Mapper public void UpdateToEntity(Exercise e, UpdateExerciseTemplate dto) { // Update basic properties e.Id = dto.Id; e.Number = dto.Number; e.IsTemplate = dto.IsTemplate; e.Name = dto.Name; e.Description = dto.Description; e.PositionLeft = dto.PositionLeft; e.PositionRight = dto.PositionRight; e.B64 = dto.B64; e.LevelId = dto.LevelId; // Remove types that exist in the database but not in the DTO var typesToRemove = e.Types .Where(existingType => !dto.Types.Any(dtoType => dtoType.Id == existingType.Id)) .ToList(); foreach (var typeToRemove in typesToRemove) { e.Types.Remove(typeToRemove); } // Add or update types from DTO foreach (var type in dto.Types) { var existingType = e.Types.FirstOrDefault(et => et.Id == type.Id); if (existingType != null) { // Update existing entity existingType.IsTemplate = false; existingType.Name = type.Name; } else { // Add new entity e.Types.Add(new ExerciseType { IsTemplate = false, Name = type.Name }); } } // Update Tempos // Find existing tempos to remove var temposToRemove = e.Tempos .Where(existingTempo => dto.Tempos.All(dtoTempo => dtoTempo.Id != existingTempo.Id)) .ToList(); foreach (var tempoToRemove in temposToRemove) { e.Tempos.Remove(tempoToRemove); } // Add or update tempos from DTO foreach (var tempoDto in dto.Tempos) { var existingTempo = e.Tempos.FirstOrDefault(et => et.Id == tempoDto.Id); if (existingTempo != null) { // Update existing entity existingTempo.Name = tempoDto.Name; } else { // Add new entity e.Tempos.Add(new ExerciseTempo { IsTemplate = false, Name = tempoDto.Name }); } } } De metoder der er gennemgået her er nok til den slemme side når det kommer til kompleksitet. Men det illusterer meget godt hvordan mindre at målet med færre driftomkostninger kan få implementerings- og vedligeldelsesomkostningerne til at stige."
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE | dadaPipes",
    "keywords": "This is the HOMEPAGE Refer to Markdown for how to write markdown files. TODO: Kom ind på hvordan at det jeg skriver om handle om/relaterer til Blazor og .NET ( vigtigt da jeg berører nærmest samtlige fokusområder, så hvert fokusområde er nødt til at omhandle .NET på en eller anden måde ). Nogle af de mest diskuterrede emner i forskellige online forumer, inden for .NET, er hvilken arkitektur og hvilke endpoints man skal bruge. Ofte er argumenterne one-liners som \"Clean Architectur is over engineering\", \"DbContext is a Repository\", \"Only test your endpoints\" osv., og man kan undre sig over, om dem som kommenterer, virkelig har en forståelse og erfaring inden for de forskellige (dele/områder/værktøjer), eller om det bare handler om præferencer. Jeg ved fra mig selv af, at jeg er super dygtig til at kritisere ting jeg ikke aner en skid om. I mange år tænkte jeg for eksemplel at Björn Afzelius var utrolig cringe, indtil at jeg lyttede til hans musik eller alt hvad der omhandler Rick James AKA Puddel Garn, udelukende baseret på hans hår. Musiken falder selfølgelig ikke i enhvers smag, og som en DJ skal vide hvilken musik han skal spille, for et bestemt publikum eller event, så skal en udvikler også vide hvilket værktøj der skal bruges i en given situation, og det er umuligt at vælge det rigtige værktøj uden at have undersøgt det grundigt først. Argumenterne fra de online forumer kan også handle om delt information bias, hvor folk har delt sig i 2 grupper med hver deres viden, hvor ved at de to grupper hver især opnår consensus. Det kan holde folk fast i bruge de værktøjer de er bekendte og dygtige i. Det samme kan gøre sig gældene i et team hvor at man vælger at gøre det som man altid har gjort, hvilket kan være nemt, bekvemt og hurtigt at komme i gang med et projekt. Men muligvis ikke den rigtige strategi på længere sigt. \"It depends\" er det universielle svar inden for software udvikling. Så hvad er det lige præcis det kommer an på ? Det er nogle af de områder jeg vil dække i min blog, omkring Blazor og .NET i web baseret udvikling. Inden at jeg startede ud med bloggen, havde jeg et projekt at arbejde på. Jeg kendte til de store dele af kravene, troede at jeg havde helt styr på hvordan koden skulle skæres og implimenteres. Jeg tog grueligt fejl (emoji). Nogle af de ting bankede hovedet ned i tastaturet over var kompleksiteten af implementeringen af dele af koden. \"Hvorfor h... skal det være så komplekst ? Er der ikke en mere simpel måde at gøre det på ?\" Men jeg havde ikke afsøgt de værktøjer (internt link) der var til rådighed med Blazor inden at jeg gik i gang. Det primære i sowtware udvikling er at løse problemer. \"Har du problem ?\" Men hvordan løser man et problem ? Man bryder det ned i mindre dele. Det lyder jo meget nemt. Der er mange andre ting man bliver nødt til at dække: Hvilke værktøjer skal man vælge og hvorfor/vælge det rigtige værktøj til jobbet ? (intern link) Hvordan sikrer man at kunden får dækket alle krav til systemet ? (intern link) Hordan sikrer man at ændringer i systemet fremover ikke skaber problemer andre steder i systemet ? (internt link). Hvordan sikrer man en dækkende og overskuelig dokumentation som er nem at lave og vedligeholde ? og sikrer at den er korrekt (forkert dokumentation er værre end ikke at have nogen dokumentation) ? (internt link) Jeg vil give mit bud på hvordan man kan løse ovenstående problemer, med udgangspunkt i en web applikation med Blazor og .NET."
  },
  "læringsmål.html": {
    "href": "læringsmål.html",
    "title": "Læringsmål | dadaPipes",
    "keywords": "Læringsmål Primære: Blazor og ASP.NET Viden (Huske of Forstå) Blazor Identificere forskelle mellem Blazor Server og Blazor WebAssembly – herunder forskellen mellem Bazor WebAssembly og Blazor Server, og hvilke fordele og ulemper de hver især medfører. ASP.NET Core Redegøre for ASP.NET Core’s arkitektur og anvendelse i webudvikling, herunder hvordan frameworket understøtter skalerbarhed og responsive API’er. Færdigheder (Anvende og Analysere) Blazor Udvikle og tilpasse komponenter i Blazor til at skabe en brugervenlig og interaktiv frontend. ASP.NET Core Implementere RESTful API’er med ASP.NET Core, der effektivt håndterer CRUD-operationer og understøtter integrationen med en frontend udviklet i Blazor. Analyse af dataflow og komponentinteraktioner i Blazor – analysere, hvordan data håndteres og udveksles effektivt mellem Blazor-komponenter og backend. Kompetencer (Evaluere og Skabe) Evaluering af teknologi: Bedømme og begrunde valget mellem Blazor WebAssembly og Blazor Server baseret på performancekrav, udviklingstid og brugerbehov. Design og udvikling af en samlet webapplikation: Kombinere Blazor og ASP.NET Core i en skalerbar løsning, der håndterer både frontend og backend på en måde, der understøtter både brugervenlighed og dataintegritet. Sekundære: Database, Sikkerhed og Docker Viden (Huske og Forstå) Database: Forklare grundlæggende databaseoperationer og forstå forskellen mellem relationelle og NoSQL-databaser. Sikkerhed: Identificere centrale sikkerhedsprincipper, såsom autentifikation og autorisation, og hvordan de kan implementeres i ASP.NET Core. Docker: Redegøre for Docker’s anvendelsesområder i softwareudvikling, herunder containerisering af applikationer for at sikre konsistens og skalerbarhed. Færdigheder (Anvende og Analysere) Database: Behandle data med Entity Framework Core i ASP.NET Core, samt integrere databasen med Blazor-frontend. Sikkerhed: Implementere basale sikkerhedsmekanismer i ASP.NET Core, f.eks. via autentifikation og beskyttelse af API’er. Docker: Afprøve og applikationen i en Docker-container, hvilket muliggør lettere test og drift på tværs af forskellige miljøer. Kompetencer (Evaluere og Skabe) Sikkerhedsvurdering: Evaluere og sikre backend-løsningen mod almindelige trusler. Feedbackhåndtering og iterativ udvikling: Sikre kontinuerlig forbedring af applikationen ved at facilitere feedback fra Product Owner gennem iterativ udvikling, hvor test og evaluering muliggøres ved at trække den nyeste version fra Docker Hub."
  },
  "testFolder/testOne.html": {
    "href": "testFolder/testOne.html",
    "title": "Test One | dadaPipes",
    "keywords": "Test One"
  },
  "testFolder/testTwo.html": {
    "href": "testFolder/testTwo.html",
    "title": "TestTwo | dadaPipes",
    "keywords": "TestTwo"
  }
}