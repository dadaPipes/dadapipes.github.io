{
  "docs/Afslutning.html": {
    "href": "docs/Afslutning.html",
    "title": "Afslutning | dadaPipes",
    "keywords": "Afslutning Kunden har altid ret. Produkt owner dikterer hvad og hvordan at applikationen skal laves. Vi er der blot for at rådgive, ud fra den tekniske viden vi har, og lede kunden ind på hvad det er de gerne vil opnå og hvordan. Man må parkere sit ego for en stund og slippe det løs på StackOverflow udenfor arbejdstid. Som udgangspunkt skal man tænke at PO ikke ved noget som helst om webudvikling og hvilke muligheder der eksisterer og hvad man kan forvente. Derfor er vi nødt til at tage dem i hånden og stille alle de simple spørgsmål som, hvilken besked vil du gerne have tilbage hvis du taster dit password forkert 1, 2 eller tre gange ? og så præsenterer dem for de muligheder der er for feed back. Det er som udvikler arrogant at tro at man ved bedre end PO og derfor er det en essentiel del af udviklingsfasen at spørge ind, både åbent, men også i detaljer. At jonglere med kontakt til PO, dokumentation, front- og backend-udvikling er som at spille 4D-skak. Der er både dybde og bredde at tage højde for, men også en dimension af tid, der styrer, hvornår og hvordan tingene hænger sammen. Hvert træk påvirker ikke kun nuet, men også fremtiden, og alt er forbundet i en større helhed, hvor planlægning og overblik er afgørende for succes. Måske skal dette omskrives og med: Douglas Adams’ \"The Answer to Life, the Universe, and Everything\" (42): Brug dette som en humoristisk henvisning til at finde løsningen: \"Vi er på jagt efter vores egen version af 'svaret på livet, universet og alt', der samler alle tråde.\" Occam's Razor vs KISS ( ikke bandet) \"Vi skal finde en løsning med minimal kompleksitet – som Occam’s Razor foreskriver.\" Andre ting der skal flettes ind i det: Fleksibilitet og skalering: First we take Manhattan, then we take Berlin. Dokumentanion og fordele ved acceptence tests: Ofte når der bliver spurgt ind til hvordan at man sætter sig ind i en kodebase hvor der er manglende eller mangelfuld dokumentation, så er svaret ofte at man skal læse testene for at sætte sig ind i hvad koden gør eller at sætte et breakpoint og hakke sig igennem systemet. Hvis man læser unit tests, så kan man se hvad de enkelte dele i systemet gør, men man for ingen forståelse af hvordan at systemet hænger sammen. Hvis man derimod kigger på acceptence tests, som er det højeste niveau inden for tests og omhandler hvordan en bruger interigerer med systemet, så får man hurtigere et overblik over hvordan at systemet hænger sammen og hvad det gør. Man kunne med fordel dele testene op i 2. Tests for hvad at en bruger vil opnå i en given test, og tests"
  },
  "docs/Api.html": {
    "href": "docs/Api.html",
    "title": "API | dadaPipes",
    "keywords": "API Skriv om API, controllers, minimal API og FastEdnpoints, helt overordnet. Kode Eksempel: Opdatering af det mest komplekse objekt og hvordan det håndteres i interactive Server og interactive WebAssembly."
  },
  "docs/Arkitektur.html": {
    "href": "docs/Arkitektur.html",
    "title": "Arkitektur | dadaPipes",
    "keywords": "Arkitektur Når man udvikler i .NET til webapplikationer, spiller valg af arkitektur en afgørende rolle for, hvordan systemet struktureres, vedligeholdes og skaleres. To populære arkitekturer er Clean Architecture (lagdelt arkitektur) og Vertical Slice Architecture (lodrette skiver). Begge arkitekturer har deres styrker og kan tilpasses forskellige behov, uanset om systemet bygges som en monolit eller som et distribueret system – enten ved hjælp af en central API eller gennem microservices. Clean Architecture fokuserer på at adskille applikationens forretningslogik fra tekniske detaljer. Den giver en tydelig lagdeling, der gør det nemt at vedligeholde og teste systemet, især i større løsninger. Vertical Slice Architecture tager derimod udgangspunkt i funktionalitet frem for lag, hvilket betyder, at hver feature behandles som en selvstændig enhed med sin egen logik, dataadgang og præsentationslag. Denne tilgang kan gøre koden mere fokuseret og nemmere at navigere, især i projekter med høj kompleksitet eller mange uafhængige features. Valget mellem de to arkitekturer afhænger ofte af projektets størrelse, kompleksitet og behovet for fleksibilitet. Mens Clean Architecture er ideel til større projekter, hvor strukturel klarhed er altafgørende, er Vertical Slice Architecture oplagt, når man ønsker at undgå overflødige lag og i stedet fokusere på funktionelle enheder. Når man kombinerer disse arkitekturer med forskellige implementeringsformer (monolit eller distribueret system), er der også andre faktorer at tage højde for, såsom skalerbarhed, teamets størrelse og behovet for uafhængig udvikling af forskellige dele af systemet. Arkitektur varianter Clean Architecture Vertical Slice Arkitektur Steven Smith om CA Fordele Tydelig adskillelse af ansvar Hvert lag har et klart og veldefineret ansvar, hvilket gør det nemmere at forstå og vedligeholde koden. Testbarhed Du kan planlægge og skrive unit tests allerede før implementeringen, da du ved, hvilke dele af applikationen der skal testes, og hvad der skal testes for. Dette muliggør brugen af Unit Test Driven Design (UTDD), hvor tests fungerer som en guide for implementeringen. Brugen af interfaces gør det nemt at sikre, at både \"happy paths\" og \"edge cases\" dækkes gennem tests. Interfaces sikrer en kontrakt, der kun dækker returtyper og argumenter, men ikke forretningslogikkens kanttilfælde. Ved at skrive unit tests for interfaces kan man validere, at implementeringer opfører sig korrekt i alle scenarier. Et særskilt Core-testprojekt kan anvendes til at teste hele Core-laget, hvor forretningslogikken er placeret, og sikrer, at alle interfaces er dækket og overholder deres kontrakter. Udvidelighed Arkitekturen gør det nemt at udskifte eller ændre dele af systemet. Hvis du fx ønsker at skifte EF Core ud med en anden ORM eller database, behøver du kun at opdatere UserRepository, uden at påvirke resten af applikationen. Forudsigelighed og konsistens Når du arbejder på en ny feature, ved du præcis, hvordan den skal opdeles, fordi hver del af koden har en fast plads i strukturen. Hele kodebasen er bygget op på samme måde, hvilket giver en ensartet struktur og gør det lettere for teamet at navigere og samarbejde. Overholdelse af SOLID-principper og DRY Denne arkitektur lægger ofte vægt på at følge SOLID-principperne (Single Responsibility, Open/Closed, etc.) og DRY-princippet (Don't Repeat Yourself). Dette skaber en mere struktureret og genanvendelig kode. Modellering på low-level niveau Når der allerede er fastlagt klare programmeringsmønstre, gør det det muligt at modellere på low-level niveau med diagrammer som fx [indsæt diagramnavne]. Low-level design giver et overblik over specifikke features, inden de bliver implementeret. Dette er især nyttigt for udviklere, der ønsker en visuel forståelse af, hvordan dele af systemet fungerer. Dog øger det kompleksiteten at sikre sporbarhed mellem design-diagrammer og kode. Interessenter fokuserer sjældent på den konkrete implementering, men på interaktiviteten. Derfor bør low-level design kun bruges som et værktøj til udviklere, ikke som et krav. Løs kobling mellem lag Brugen af interfaces fremmer løs kobling, hvilket gør det nemt at skifte lag ud, fx at erstatte en service eller et repository. Ulemper Overhead og fragmentering Enkel kode skal opdeles i mange små filer og lag, hvilket kan føles overflødigt i mindre eller simple projekter. Den samme struktur skal følges i hele applikationen, selvom det måske ikke er nødvendigt i alle dele. Låst fast i et mønster Koden bliver bundet til en bestemt arkitektur allerede fra starten, hvilket kan begrænse fleksibiliteten, hvis kravene ændrer sig senere. Det giver udvikleren nogle meget stramme rammer for hvordan at de kan implementere en feature. Kompleksitet i projektstruktur Nogle arkitekturer placerer lagene i separate projekter i stedet for blot foldere. Dette kan gøre det lettere at udskifte lag, men øger samtidig den samlede kompleksitet og kan være unødvendigt, hvis der ikke er behov for at skifte lagene ud senere. Overflødig brug af repositories og interfaces Et almindeligt argument i .NET-verdenen er, at repositories og interfaces gør det lettere at skifte database. Men i praksis fungerer EF Core allerede som et repository via DbContext og understøtter mange forskellige databaser. Derfor kan det virke som overengineering at bygge et ekstra lag ovenpå. Tidskrævende implementering Den høje brug af interfaces og unit tests betyder, at udviklingen tager længere tid. Samtidig øger det kompleksiteten i både implementeringen og vedligeholdelsen af koden. Kompleksitet i pull requests Når kode er spredt ud på mange små filer og lag, bliver det mere udfordrende at gennemgå pull requests og få et overblik over de ændringer, der er lavet. Dette kan også gøre det vanskeligere og mere tidskrævende at godkende pull requests. Jimmi Bogard om VSA Man deler koden op i lodrette snit, typisk per feature, som er placeret i 1 folder. I en serverside applikation hvor at både front- og backend kører på serveren, kan et snit bestå af en Blazor komponent og alt loggiken der hører til den specifike komponent. I en WebAssembly applikation, som er delt op i flere projekter, vil man have foldere med det samme navn i hver projekt, som har alt hvad der er hører til den specifike feature. Fordele Det er nemmere at overskue en feature, når al kode relateret til den ligger i samme mappe, fremfor at være spredt ud over flere mapper og projekter. Selv i et distribueret system med Client-, Server- og Shared-projekter forbliver strukturen overskuelig, da mapperne har samme navne og er organiseret på samme måde. Da koden er opdelt per feature, bliver det nemmere for nye udviklere at sætte sig ind i kodebasen og forstå, hvordan den fungerer. Debugging bliver enklere, fordi al relevant kode til en feature er samlet ét sted. Features er isolerede fra hinanden. Ændringer i én feature påvirker ikke andre og har ingen sideeffekter, hvilket giver udviklere større tryghed, når der deployes til produktion. Udviklere har større frihed til at implementere kode på den måde, de finder bedst. En feature kan betragtes som en \"black box\", der kun interagerer gennem requests og responses. Integrationstests kan nemt implementeres og dække hele systemet på højeste niveau, da al påvirket kode er samlet ét sted. Samtidig sikrer unit tests i domænelaget, at delt forretningslogik fungerer korrekt. Selvom det er valgfrit, kan unit tests stadig bruges til komplekse metoder for at spare tid og reducere debugging. Dette kan sammenlignes med at unit teste private metoder, som understøtter public metoder. På samme måde understøtter metoder i et snit en feature i at overholde kravene. Pull requests bliver mere overskuelige at gennemgå, da alle ændringer relateret til en feature er samlet ét sted, hvilket også gør historikken nemmere at spore. Ulemper Da der ikke er kode, der deles på tværs af lagene, kan det føre til gentagelser (mod DRY-princippet). Men i praksis kan det være mere hensigtsmæssigt at gentage sig selv i visse tilfælde fremfor at abstrahere for meget. Erfaring er nøgleordet her. Delt forretningslogik kan stadig placeres i domænelaget, hvor det giver mening, for at undgå overflødig gentagelse. Modelering Fokus bør være på high-level diagrammer, der er relevante for interessenterne, da de typisk ikke interesserer sig for implementeringsdetaljer. Det er muligt at modellere på low-level niveau, men ofte er det mere effektivt at lade udviklere, der implementerer featuren, tage sig af detaljerne. En TDD-tilgang kan her være fordelagtig, hvor kode og tests dikterer implementeringen. Ved at prioritere high-level diagrammer frigives der mere tid til at designe systemet på en måde, der betyder noget for interessenterne. Low-level modellering: Det er muligt at modellere på low-level niveau, som f.eks. sekvensdiagrammer eller klasse-diagrammer, især når programmeringsmønstre er fastlagt. Dog øger dette kompleksiteten, da sporbarhed mellem design og kode skal opretholdes. Low-level design bør kun bruges, hvis en udvikler ønsker et overblik over en feature før implementering. Interessenter bekymrer sig sjældent om implementeringsdetaljer. Tests Hver feature-mappe er isoleret fra andre, hvilket gør det nemt at debugge og rette fejl uden at risikere sideeffekter i andre features. Den mest effektive testtilgang i VSA er en ATDD-tilgang med fokus på endpoints. Unit tests: Det anbefales kun at bruge unit tests for komplekse metoder, hvor de kan spare tid ved at eliminere behovet for gentagen debugging. Da alle features har adgang til domænelaget, er det vigtigt at unit teste forretningslogikken i dette lag. Fejl i domænelaget kan have sideeffekter på tværs af flere features, og derfor bør det testes grundigt. I domænelaget er det ikke nok kun at dække kode med interfaces. Interfaces sikrer kun en begrænset kontrakt med fokus på return-typer og parametre, hvilket kan føre til, at edge cases overses. Derfor er det vigtigt at lave unit tests for interfaces, så alle edge cases i domænet dækkes. Dette gøres bedst med et dedikeret domæne-testprojekt. Monolith vs Distribueret system CA Interactive Server eksempel CA Interactive WebAssembly (TODO) VSA Interactive Server eksempel VSA Interactive WebAssembly eksempel UI Infrastructure InfrastructureServices DataAccess EfCore ApplicationCore DomainServices Interfaces Domain Component.cs ViewModel.cs Endpoint.cs InfraService.cs Repository.cs Migrations.cs DbContext.cs DomainService.cs IDomainService.cs IInfraService.cs IRepository.cs Entity.cs CA interactive webassembly Simpel Feature Kompleks Fetature Component.razor Component.razor ViewModel.cs IRepository.cs Repository.cs Simple Features Client Server Shared Component.razor Endpoint.cs DTO.cs Validation.cs Komplekse Features Client Server Shared Component.razor Service.cs Endpoint.cs IService.cs Service.cs Mapper.cs IRepository.cs Repository.cs DTO.cs Validation.cs CA VS VSA Får man senere brug for at kunne skalere dele af applikationen, kan man plukke enkelte features ud og lave dem om til microservices. Dette er dog på bekostning af en højere kompleksitet. Man ser ofte, når man læser om arkitektur, at en bestemt arkitektur passer godt til en bestemt størrelse af applikationer. Dette vurderes typisk ud fra faktorer som kompleksitet, overblik, udviklerteamets kendskab til arkitekturen eller andre udviklingsrelaterede parametre. Men det er som nævnt ofte baseret på udviklerperspektivet. Det, der burde være i fokus, er ikke ovenstående faktorer, men i stedet hvad kravene til applikationen er, og hvad der passer bedst til den konkrete situation. Jo mere kompliceret applikationen er, jo højere er omkostningerne til udvikling og vedligehold. Ting, der kan øge omkostningerne, og som man skal overveje: Overskuelighed og navigation i koden (man bruger mere tid på at læse kode end på at skrive den). Tilføjelse af nye features. Ændring af eksisterende features. Antal tests. Antal abstraktioner. Mængden af kode. CA (blå linie) Høj kompleksitet fra start, da man allerede inden den første linje kode har oprettet flere projekter i applikationen. Hver feature, der implementeres, har høj kompleksitet, som ikke kan reduceres. VSA (mellem blå og sort linie) Lav komplesitet fra start. Hver feature, der implementeres, er fleksibel og kan have enten lav eller høj kompleksitet afhængigt af behov. --- config: themeVariables: xyChart: plotColorPalette: \"#000000, #0000FF\" --- %% plotColorPalette: \"black, blue\" xychart-beta title \"Omkostninger per feature\" x-axis \"Features (Antal)\" [0, 10, 20, 30, 40, 50, 60,70, 80, 90, 100] y-axis \"Omkostninger\" 0 --> 20000 line [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000] line [4000, 6000, 8000, 10000, 12000, 14000, 16000, 18000, 20000] Som udgangspunkt er det en god ide at holde det simpelt (KISS-princippet), og man skal ikke spekulere for meget på, hvad applikationen måske kan udvikle sig til i fremtiden (YAGNI-princippet). At gætte på fremtidige behov kan komplicere kodebasen unødvendigt, og kompleksitet koster penge i både implementering og vedligehold. Der skal derfor være en meget god grund til at vælge Clean Architecture for at retfærdiggøre den øgede kompleksitet. Med fokus på arkitektur er Vertical Slice Architecture det mest simple at starte med. Hver \"skive\" har ét fokusområde, og alt, hvad denne skive skal bruge, er samlet i én folder. Hvis man i fremtiden skulle få brug for at genbruge domænedelen af applikationen, kan man opdatere én skive ad gangen, indtil man har et domæne, der kan skilles ud og deles på tværs af projekter. Repositories har sine fordele, men de er ikke altid nødvendige, især når man kan bruge en ORM (Object Relational Mapper) som EF CORE, der fungerer som dataadgangslag til en database. Hvis man skulle få brug for at skifte til en anden database (jf. YAGNI-princippet), understøtter EF Core allerede mange forskellige databaser via DbContext. Når man afklarer kravene til applikationen, kan man i modelleringsfasen dele applikationen op i dele som i Feature Driven Development: Theme Epic Feature User Story Disse kan afspejle mappestrukturen i applikationen, hvilket giver sporbarhed mellem modellen og applikationen. Udover sporbarhed giver det, som applikationen udvikler sig, en klar afgrænsning af domænet, hvilket kan være svært at opnå enighed om i et team. Hvis applikationen på sigt bliver stor nok, kan dele af den nemt skilles ud og håndteres som selvstændige services, der kan bruges på tværs af andre applikationer."
  },
  "docs/Blazor.html": {
    "href": "docs/Blazor.html",
    "title": "Blazor | dadaPipes",
    "keywords": "Blazor Jeg har undersøgt og sammenlignet de forskellige relevante Blazor varianter, for web udvikling, i .NET 8.0 Blazor gør det muligt at udvikle moderne, interaktive brugerflader direkte i C#. En stor fordel er, at Blazor også understøtter JavaScript, hvilket åbner op for brug af JavaScript-biblioteker og man kan skrive kode i Java Script. Introduktionen af Blazor Web App i .NET 8.0 har gjort det muligt at mixe forskellige render modes i Blazor, til forskel for .NET 7.0 hvor man kun kunne vælge imellem Blazor Server eller Blazor WebAssembly for sin applikation. Man kan sætte rendermode til for hele applikationen og ikke tænke mere over det eller man kan sætte en rendermode for hver individuel komponent. Det giver mere fleksibilitet, men også en højere kompleksitet, da man har UI komponenter i både et Client og Server projekt at holde styr på. Hvilken render mode man kan vælge og hvorfor, kigger jeg nærmere på herunder. Blazor Varianter Interactive Server Interactive WebAssembly Interactive Auto Blazor Standalone + PWA Sådan fungerer det Serveren sender kun det det indhold der skal bruges, når en bruger navigerer til en side, og hvis brugeren har adgang til siden. Dataen bliver sendt via en SignalR-forbindelse, der muliggør realtidskommunikation mellem serveren og klienten gennem websockets (eller alternative protokoller som Server-Sent Events eller Long Polling, hvis websockets ikke er tilgængelige). Interaktivitet Brugeraktivitet behandles direkte på serveren af ASP.NET Core runtime. Stateful (tilstandsfuld): Applikationens tilstand er afhængig af en konstant forbindelse til serveren. Serveren håndterer forbindelsen for alle forbundne klienter og opdatering af UI. Fordele Hurtig initial indlæsning da alt bruger aktivitet på siden forgår direkte via serveren. Skal kun downloade Java Script, HTML og CSS per side. Uanset hvor stor applikationen er, vil den loade hurtigt. Lavere krav til klientens ydeevne, da alt beregnes på serveren. Man behøver kun 1 server projekt. Organisering af kode er enkelt da det er en monolith (med mindre at man bruger micro services). Ulemper Netværk: Afhængighed af en stabil netværksforbindelse. Hvis forbindelsen afbrydes, mister applikationen sin funktionalitet. Omkostninger: Høj belastning på serveren, især ved mange samtidige brugere eller meget interaktivitet. Udsving i netværksforbindelsen kan påvirke brugeroplevelsen negativt. Sikkerhed Da hele applikationen ligger på serveren, kan man sikre at det kun er brugere med de rette brugsrettigheder, der har adgang til specifike komponenter, sider eller layouts. Man kan bruge en ViewModel som man binder til en komponent, og validere modelen med eksemspelvis dataannotations eller FluentValidation. Det giver brugeren direkte feedback i klienten, men validering i klienten kan manipuleres, eksempelvis via Dev Tools, hvis klienten er en browser. Da man allerede har validering for ViewModelen, kan man bruge den samme i en service eller metode der kører på severen, som en bruger ikke har direkte adgang til. Sådan fungerer det .NET runtime og app bundle downloades og lagres i browserens cache, ved første indlæsning en komponent. Komponenter skal bygges fra et separat client projekt, der opsætter Blazor WebAssembly-værten. Skal der sendes eller modtages data til eller fra en server, foregår det via en API, typisk via HTTPS. Interaktivitet Brugeraktivitet håndteres direkte i klientens browser. Stateless (tilstandsløs): Den håndterer tilstanden af applikationen i browseren, uafhængig af serveren, da alt er lagret i browseren. Fordele Kan bruges offline, efter at den er downloaded, da klient delen ligger, der er catched i browseren, så den kan stadig fungere, selv hvis netværksforbindelsen svigter efterfølgende. Hurtig UI-reaktionstid, da al interaktivitet udføres lokalt i browseren uden afhængighed af netværksforbindelsen, og man kan opnå en hastighed der er det tæt på desktop app hastighed. Klient- og serverprojekt kan udvikles og skaleres separat. Server projektet (API) kan bruges til forskellige klienter. Man kan bruge den samme C# kode for validering i både Klient og Serber projektet. Ulemper Længere initial indlæsningstid da hele klientprojektet skal downloades før at en bruger kan interigere med applikationen. Kræver en mere kraftfuld klientenhed, da al interaktion foregår lokalt i browseren. Er afhængig af en et .NET serverprojekt for at kunne fungere, da det er serverprojektet der 'serverer' klientprojekt til browseren Sikkerhed I en WebAssembly-applikation downloades og caches alle komponenter i browserens cache, hvilket giver brugeren adgang til hele klientprojektet via værktøjer som browserens Developer Tools. Validering skal derfor altid foretages på backenden (serveren) for at sikre dataintegritet og forhindre misbrug. For eksempel kan man ved at højreklikke på et website, vælge Inspicér, og navigere til fanen Application finde cachelagrede filer under Cache Storage. Intet i klienten er skjult eller sikkert fra brugere med adgang til Developer Tools. UI-komponenterne i Blazor WebAssembly tilbyder ikke reel sikkerhed mod uautoriserede brugere, da eventuelle adgangsbegrænsninger i UI’et kun er kosmetiske. Det er derfor afgørende at beskytte API'en og sikre korrekt adgangskontrol og validering på serveren frem for at stole på UI-komponenternes sikkerhed. Sådan fungerer det Fungerer som Blazor WebAssembly, men med den vigtige forskel, at .NET runtime kører på serveren, indtil hele applikationen er downloadet og cached i brugerens browser. Dette giver en hurtigere \"first render\" for brugeren og en mere glidende overgang til en fuldt klientbaseret applikation. Fordele Brugeren kan se og interagere med UI'et næsten med det samme, fordi serveren midlertidigt håndterer logik og rendering. Dette skaber en hurtig og responsiv oplevelse, selv for brugere med langsom internetforbindelse, da serveren kun skal håndtere den specifike side som brugeren har navigeret til. Når applikationen er fuldt downloadet og cached, skifter den automatisk til at køre som en Blazor WebAssembly-app, hvilket reducerer serverbelastningen og udnytter klientens ressourcer optimalt. Brugeren oplever derfor ikke en tom side eller en langsom load-fase, da serveren straks leverer UI. Ulemper Brugeren kan se UI'et hurtigt, men de kan ikke sende eller modtage data fra API'en, før .NET runtime er fuldt downloadet og kører lokalt i browseren. Dette kan give en begrænset interaktivitet i starten. Overgangen fra server til klient kan skabe potentielle problemer, hvis noget går galt under download eller caching-processen. Blazor Standalone bygger på samme klient-side rendering (CSR)-principper som Blazor WebAssembly, men adskiller sig ved ikke at være afhængig af en .NET-server til hosting. Den genererer en samling statiske filer som HTML, CSS og JavaScript, som kan hostes på enhver server, der understøtter levering af statiske filer. Dette gør den særligt velegnet til enklere hostingløsninger, mens forretningslogik og databaseadgang håndteres via en ekstern API. Blazor Standalone deler mange af de samme fordele og ulemper med Blazor WebAssembly: Hurtig UI-reaktionstid, offline-funktionalitet og genbrug af C#-kode. Samtidig kræver begge løsninger, at sikkerhed og validering implementeres på serversiden. Den væsentligste forskel ligger i Blazor Standalones større hostingfleksibilitet og dens mangel på indbygget Microsoft Identity-support. Fordele Kan hostes på enhver server, der understøtter statiske filer, inklusiv billigere løsninger som GitHub Pages eller Azure Static Web Apps. Kræver ikke en .NET-server til at levere klientprojektet, hvilket kan reducere kompleksiteten i drift. Hurtig UI, offline-funktionalitet og genbrug af C#-kode gælder også for Blazor Standalone. Ulemper Blazor Standalone-templaten inkluderer ikke en indbygget løsning med Microsoft Identity til authentication. Udviklere skal selv implementere sikkerhed, ofte ved brug af tredjepartsløsninger eller en API, der sikrer kommunikationen. For at sikre forbindelsen mellem Blazor Standalone og en API anbefales det ofte at bruge OpenID Connect (OIDC) med en Identity Provider (IP). Dette kan øge kompleksiteten og afhængigheden af tredjepartsudbydere. Dokumentation om emner som sikkerhed og cookiebaseret authentication i Blazor Standalone er sparsom. Dette kan gøre det udfordrende at implementere robuste løsninger uden ekstern hjælp. Manglen af dokumentation gælder også authentication for OIDC udbydere som OAuth, da Blazor Standalone er ikke lige så udbredt som andre frameworks som React, Angular eller Vue. Progressive Web App En Progressive Web App (PWA) er en webapplikation, der kan downloades og lagres i browserens cache. Dette gælder for Interactive WebAssembly, Interactive Auto og Standalone applikationer. Efter download kan applikationen installeres direkte på klientens enhed. Ordet \"Progressive\" refererer til, at en bruger starter med at opdage applikationen via browseren og derefter kan fortsætte med at installere den som en app på sin enhed. Fordele Kan køre offline og starte med det samme, uafhængigt af netværksforbindelse, hvis applikationen er downloadet. Kan køre i sit eget vindue, uafhængigt af browseren. Kan startes fra brugerens operativsystems startmenu eller skrivebord med et dedikeret ikon. Understøtter push-notifikationer og kan håndtere baggrundsopgaver via en service worker, selv når applikationen ikke aktivt bruges. Kan bruges på alle enheder med en browser, herunder desktop, laptop, tablet og mobiltelefon. Kan downloades fra platforme som App Store eller Microsoft Store. Bygger bro mellem web og native apps ved at udnytte standard webteknologier til funktioner, der tidligere krævede enhedsspecifikke programmeringssprog. Dog er der stadig begrænsninger, afhængigt af brugerens browser og enhed. For et overblik over, hvad der understøttes i forskellige browsere, kan man besøge What Web Can Do Today. Denne liste opdateres løbende, da browser- og OS-udviklere konstant udvider adgangen til native funktioner. Funktioner som filsystemadgang og hardwarekonfiguration vil dog sandsynligvis forblive sandboxed af sikkerhedsmæssige årsager. Ulemper I Blazor Standalone-templaten kan man tilvælge PWA, men dette gælder ikke for Blazor Web App Interactive WebAssembly-templaten, hvor PWA-funktionaliteten skal tilføjes manuelt. Applikationen kan kun testes manuelt i offline-tilstand efter deployment. Opdateringer er kun tilgængelige, hvis brugeren lukker applikationen helt. En simpel opdatering af browseren er ikke tilstrækkelig. Dette skal overvejes af udviklere og kommunikeres klart til brugerne. Hvis en opdatering udrulles, som ikke er kompatibel med tidligere versioner, kan brugeren risikere at miste adgang til applikationen uden at forstå hvorfor. Det er afgørende at kommunikere opdateringer tydeligt (noget som eksempelvis NemID ikke prioriterede – rant out!). Hvis brugeren ikke har netværksforbindelse, er det ikke muligt at få en ny access token til autentificering. Dette forhindrer adgang til beskyttede dele af applikationen. Det afhænger dog af, om access tokens har en udløbstid, hvilket generelt anbefales. Omkostninger Udvikling Blazor Server Da koden er samlet i ét projekt, er det hurtigt og nemt at implementere nye funktioner. Kodebasen er enkel og gør det muligt at udvikle direkte i en enkelt komponent uden at skulle opdele koden i separate klasser, hvilket reducerer kompleksitet og sparer tid. Blazor WebAssembly Applikationen kræver opdeling i to projekter: frontend og backend. Dette betyder ekstra opsætning og behov for et delt bibliotek til DTO'er (Data Transfer Objects) for at sikre korrekt dataoverførsel mellem frontend og backend. Det kan tage længere tid at strukturere og udvikle funktioner sammenlignet med Blazor Server. Blazor Standalone Opsætning af sikkerhed og authentication kræver betydelig indsats og erfaring, især hvis der bruges tredjepartsbiblioteker eller custom integrationer. Dette kan føre til længere udviklingstid sammenlignet med de andre løsninger. Vedligehold Blazor Server Den simple struktur gør det nemt at organisere og overskue kodebasen, hvilket gør vedligeholdelse relativt enkel. Nye udviklere kan hurtigt forstå applikationens opbygning. Blazor WebAssembly Vedligeholdelse kan være mere kompleks, da frontend og backend skal holdes synkroniseret, især ved ændringer i API'et eller DTO'er. Et delt bibliotek kan reducere risikoen for fejl, men det introducerer en afhængighed, der kræver løbende opdatering. Blazor Auto Samme som WebAssembly Blazor Standalone Authentication og sikkerhedsløsninger er ofte brugerdefinerede og kræver løbende tilpasninger, især når tredjepartsbiblioteker ændrer standarder. Dette kan gøre vedligeholdelse mere tidskrævende end de andre modeller. Drift Blazor Server Hele applikationen kører på serveren, hvilket kan føre til betydelige omkostninger ved høj brugeraktivitet. Serveren skal håndtere både forretningslogik og UI-opdateringer, hvilket kræver kraftigere serverressourcer og begrænser fleksibiliteten i hosting. Blazor WebAssembly Klienten kører direkte i brugerens browser, hvilket reducerer belastningen på serveren. Dette resulterer ofte i lavere serveromkostninger, især ved mange samtidige brugere, da backenden kun håndterer API-kald. Ressourcer caches i browseren, hvilket reducerer behovet for gentagne downloads. Blazor Standalone Hostingomkostningerne er typisk lave, da applikationen kun består af statiske filer. Dette gør Standalone til en økonomisk løsning, hvis der ikke er behov for en server. Hvis der kræves en backend til forretningslogik via API, kan driftsomkostningerne stige og gøre løsningen mindre fordelagtig sammenlignet med andre modeller. Blazor Auto Interactive Auto har stort set samme omkostninger som Blazor WebAssembly, da serveraktiviteten kun er midlertidig, indtil applikationen er downloadet og kører som WebAssembly. Hostingomkostningerne kan være en anelse højere i applikationens opstartsfase, men dette er typisk ubetydeligt, da brugeren hurtigt overgår til en klientbaseret oplevelse. Omkostninger PWA Da PWA skilder sig ud ved at være en tilføjelse til applikationen har den sit eget afsnit. Udvikling Blazor Standalone: Tilføjelsen af PWA-funktionalitet kræver en konfiguration af en service worker og en manifestfil. Det er en relativt simpel proces, især med indbyggede templates, hvilket gør det hurtigt at implementere PWA i applikationen. Blazor WebAssembly: PWA skal konfigureres manuelt, da standard WebAssembly-template ikke inkluderer PWA. Dette kræver mere tid og erfaring med service workers og caching-strategier, hvilket kan øge udviklingstiden. Vedligehold PWA kræver, at service workers holdes opdateret for at sikre, at applikationen fungerer korrekt, især ved ændringer i kodebasen. Derudover skal versionering håndteres effektivt for at undgå problemer med kompatibilitet mellem applikationsversioner. Opdateringshåndtering kan også være en udfordring, da applikationen kun vil blive opdateret, når brugeren lukker og genstarter den, hvilket kræver opmærksomhed og kommunikation fra udviklerens side. Drift Driftsomkostningerne for PWA er i vid udstrækning de samme som Interactive WebAssembly, Interactive auto eller Standalone, da store dele af applikationen caches og kører lokalt i brugerens browser."
  },
  "docs/CICD.html": {
    "href": "docs/CICD.html",
    "title": "Continious Intergration/Continious Delivery | dadaPipes",
    "keywords": "Continious Intergration/Continious Delivery CI/CD Tests, Docker. Halloa!!"
  },
  "docs/Docker.html": {
    "href": "docs/Docker.html",
    "title": "Docker | dadaPipes",
    "keywords": "Docker Docker PO I hovedsædet. Gør det muligt for PO at teste funktionalitet, interaktivetet og UI via DockerHub, uden at man skal udrulle systemet. Kan docker fixe (alternativ til) hot reload i Blazor ? Forskel på build i VS 2022 og Docker build time ? Min forståelse er at når man kører en container så opdaterer den kun det kode man har tilføjet efter at have startet den op. Ergo, den skal ikke bygge hele projektet men bygger og tilf'jer kun det nye kode, hvilket i så fald vil udmunde i en hurigere build time og muligvis fixe hot reload."
  },
  "docs/Dokumentation.html": {
    "href": "docs/Dokumentation.html",
    "title": "Dokumentation | dadaPipes",
    "keywords": "Dokumentation Swagger og alternativer TODO: få noget med om sporbarhed. Målet er at kunne sikre sporbarhed mellem den fælles dokumentation som både kunde og udvikler har til rådighed og den implimenterede kode. Ved at holde den fælles dokumentation på et højt niveau og dokumentere systemet som en sort box, kan kunde og udvikler få et hurtigt og solidt overblik over hvordan applikationen overordnet virker og hvordan enkelte dele fungerer. Hvad giver mening at dokumentere og hvorfor ? Acceptence tests for at PO og udviklere kan se hvad systemet kan, gør og begrænsninger i forskellige komponenter. Delte objekter: API: Utility: Domæne modeller: Globale objekter: Error response i API. andre globale objekter EKS (?) summary, XML comments, DocFX, GhostDoc Automatiseret dokumentation er tidsbesparende, færre fejl og bliver opdateret automatisk. API: DocFX statisk documentation og .NET .json der kan bruges til API tests i eksemplevis Swagger. Ved at dokumentere Acceptence Tests med xunit.gherkin.quick og DocFX, giver det et overblik for både product owner og udviklere der arbejder op applikationen. Det er især værdifuldt for Product Owner, da de hurtigt kan få et overblik over hvad det at systemet gør, uden at kende til detaljerne omkring hvordan at det gør det. Man sikrer sig også at dokumentationen altid er up to date samtidig med at man sikrer sporbarhed imellem kravene til applikationen og hvordan systemt virker. Ved at dokumentere kravene til applikationen, bliver det nemmere for nye udviklere at sætte sig ind i hvad systemet gør. Ved at dokumentere de dele af koden som man ved bliver brugt af forskellige andre dele af koden og som kan bruges når der laves nye features, så kan man nøjes med at kigge i dokumentationen frem for at grave ned i implementeringe af de forskellige objekter, for at finde ud af hvordan at de virker. Selve implementeringen at et objekt er ofte ikke så interesant. Med en gennemført dokumentation af systemet og kodebasen får man et bedre overblik."
  },
  "docs/EksPåAndvendelse/RandomEksempel.html": {
    "href": "docs/EksPåAndvendelse/RandomEksempel.html",
    "title": "Random Eksempel | dadaPipes",
    "keywords": "Random Eksempel Da jeg startede ud med at lave systemet, så begik jeg så mange fejl. Jeg kodede med hovedet oppe i røven og hev kode ud fra det samme sted. Fik ikke afklaret kravene klart nok, så implementeringen af koden var i mange tilfælde tilfældig, da jeg stødte på komplikationer jeg først opdagede da jeg var i gang med at kode. Meget af det bundede i at der var ting jeg ikke vidste at man kunne gøre og ting jeg ikke vidste skulle afdækkes som et krav og hvilke muligheder der var. Ting som jeg i den grad skal have skrevet ned og systimatiseret, da en fremtidig Product Owner vil stp i samme sted som mig, da jeg startede ud med bygge systemet. Ting som hvad er der af 'response' muligheder i en web form ? Hvilke muligheder er der når man intaster noget korrket eller forkert i et input felt ? Hvad sker der hvis man 'submitter' noget der ikke er korrekt ? Hvad sker der hvis man søger på noget som ikke findes ? Hvad hvis der opstår en fejl i systemet ? Er det noget brugeren kan rette op på ? giv oplysende besked om hvordan brugeren retter op på fejlen. Er det noget brugeren ikke kan rette op på ? : giv en generisk fejl besked. Osv.. Alle de ting er noget der skal afklares når man har en snak om kravene til systemet og de forskellige dele. Mange af de ting jeg har skrevet om i bloggen er født ud af frustration over min manglende viden om hvilke muligheder jeg skulle afdække i en web applikation i forskellige brugssager. Nogle ting anede jeg ikke eksisterede før at jeg gik i gang med at skrive bloggen, men efter at jeg havde været igennem frustrationerne med at udvikle systemet og samtidigt gjort mig nogle tanker om hvordan at man kunne gøre det nemmere, fik jeg afsøgt nogle områder hvor at jeg kunne finde forskellige løsninger, sammenligne de forskellige værktøjer og vælge det som passer bedst ind i systemet. Ved at udvikle et projekt alene og skulle håndtere kravs insdsamling, via kommunikation med Produkt Owner, og en full stack web applikation, har det givet mig en bedre forståelse for sammenhængen mellem de forskellige dele. Det er absolut kun i retro perspektiv at det er gået op for mig hvor meget at Produkt Owner skal være i fokus, for at levere et brugbart system. Det vigtigste at jeg har lært i den her proccess, er at det i sidste ende, er Product Owner der bestemmer hvad der skal laves, hvordan det skal laves og hvornår det skal laves. Man kan så præsentere hvilke muligheder der er, baseret på ens viden på området. Det gælder både for hvilken type af applikation man vælger, baseret på forventede omkostninger af udvikling, vedligeholdelse og drift. Jo mere viden man har på området, des større en palette af muligheder kan man præsentere for Product Owner."
  },
  "docs/MudBlazor.html": {
    "href": "docs/MudBlazor.html",
    "title": "MudBlazor | dadaPipes",
    "keywords": "MudBlazor TODO: Skriv om MudBlazor. Sammenlign MudBlazor syntax med Razor syntax Link til MudBlazor"
  },
  "docs/TeckRamme.html": {
    "href": "docs/TeckRamme.html",
    "title": "| dadaPipes",
    "keywords": ""
  },
  "docs/Tests.html": {
    "href": "docs/Tests.html",
    "title": "Tests | dadaPipes",
    "keywords": "Tests Tests: I forskellige online forumer er tests et tema som bliver diskuteret meget og bølgerne kan gå højt. Ofte er det baseret på præferencer frem for funtionalitet og værdi. Unit tests er noget som udviklere beekymrer sig om og ikke et mål for Produkt owner. Unit tests er til for at sikre at mindre dele af koden fungerer efter hensigten, også hvis der bliver ændret i implementeringen af koden, på et senere tidspunkt. Hvis koden der bliver testet kun er brugt 1 sted, giver det ikke meget værdi at teste den, da det vil være nemt at debugge koden og finde fejlen. Er koden brugt flere steder i applikationen kan påvirke alle de steder i applikationen som bruger den del af koden. Derfor er det vigtigt at få testet den. Fokuspmråder for unit tests vil derfor være metoder i bibilioteker, utility klasser og domæne modeler. Ved at teste så højt oppe i systemet som muligt og fokusere på hvad brugerens krav er, er implementeringen af den undleæggende kode mere fleksibel, da ændringer i koden ikke bryder med brugerens krav. (Hold det op imod public vs private tests: \"There is some debate among practitioners of TDD, documented in their blogs and other writings, as to whether it is wise to test private methods and data anyway. Some argue that private members are a mere implementation detail that may change, and should be allowed to do so without breaking numbers of tests. Thus it should be sufficient to test any class through its public interface or through its subclass interface, which some languages call the \"protected\" interface.[14] Others say that crucial aspects of functionality may be implemented in private methods and testing them directly offers advantage of smaller and more direct unit tests.[15][16]\" https://en.wikipedia.org/wiki/Test-driven_development) Der er eksiterer kun 1 mål ( vejen er målet (?)). Der findes kun 1 form for tests. I yoga findes der, på trods af ihærdige forsøg på at sælge alt muligt andet, kun en yoga stilling, skrædderstillingen. Det er den stilling hvor at kroppen kan slappe mest af og derved den bedste stilling til at meditere og opnå oplysning. Alle andre yoga øvelser eksisterer kun som støttende øvelser, for at gøre det nemmere at kunne side i en skrædderstilling. I webudvikling findes der kun 1 form for test, acceptence test. I fuld stack vil det være en test der tager udganspunkt i UI og i en API som konsumeres af andre vil det tage udganspunkt i et endpoint. Alle andre tests eksiterer kun som støttende tests, der gør det nemmere at sørge for at acceptence testen lyser grøn. Da acceptence testen er udviklet i sammarbejde med product owner. er det på samme måde som skrædderstillingen i yoga, den test der gør det nemmest for en udvikler at slappe af i kroppen. Tengiz Tutizani giver en forklaring på hvordan at man kan automatisere Acceptence tests i .NET. Støttende tests (unit tests osv): ved komplekse metoder ( fuck mit komplekse objekt der skal opdateres og alle de ting der skal tjekkes for!! ) (Derfor er det også nemmere at finde frem til acceptence tests med PO. Det ansvar ligger hos dem, da vi jo ikke kan læse deres tanker og gerne skulle undgå at være arogante). TODO: (link til fetature page) Eksempel på en feature og acceptance test Rød, Grøn, Omstrukturer. Regler at støtte sig op af: Man skal kunne læse et endpoint eller metode på en skærm uden at scrolle. Kan man indsætte en kommentar om, hvordan koden virker, kan det indikere, at koden skal opdeles i mindre, selvforklarende dele. Acceptence test der hvor at det kommer tættest på en bruger og samtidigt kan automatiseres: Frontend Komponent => Service klassen for den enkelte komponent. Ved at bruge en service klasse for en komponent som udgangspunkt for en acceptence test, så har man frie tøjler til at ændre i UI og de klasser som Service klassen sender og modtager data fra. Det vil sige at den kan bruges hvis den kalder andre klasser direkte eller kalder en API. Tests (acceptence tests) som dokumentation. Ny Viden !!!! ATDD (acceptence test driven design), UTDD (unit test driven design), BDD (behavior driven design). [UTDD](\"Unit Test Driven Development\") er målrettet udvikleren der skal implementere koden eller testeren der skal skrive tests inden implimentering af koden. Bruger man en [lagdelt arktitektur](TODO: internt link), hvor at hvor at de forskellige dele af koden har faste pladser i hver deres lag, kan man modelere koden på forhånd og det er muligt for en tester at skrive tests, før at en udvikler implementerer koden. (TODO: Eksempel med Low-level diagram). [ATDD](\"Acceptence Test Driven Development\") er målrettet udviklere, testere og forretningsinteressenter. Bruger man en arkitektur som giver udvikleren mere frie tøjler, som eksempelvis i [VSA](TODO: internt link \"Vertical Slice Architectur\"), vil det være sværere at modelere på et low-level niveau, og for en tester at skrive unit tests før implementering af koden. Tests i Client og API. Da der kan være et team der atbejder på hver især Client og Server projektet, kan man med fordel lave både acceptence tests i klient projektet og intergration tests for endpoints i API'en. Kom ind på Publlic vs Private tests og sammenlign det med acceptence test/intergration tests af endpoints. Hvad der giver mest værdi for den tid man bruger på dem og at det giver mere frihed til at ændre i koden uden at man kommer til at bryde unnit tests. The Magic Tricks of Testing by Sandi Metz DER ER INDEKSERING MED TIDSPUNKTER I KOMMENTARENE, BRUG DEM!. Indsæt links: ... Xunit.Gherkin.Quick Reqnroll User Stories"
  },
  "docs/Udvikling.html": {
    "href": "docs/Udvikling.html",
    "title": "Udviklings metoder | dadaPipes",
    "keywords": "Udviklings metoder TODO: opdtater: Ser man bort fra projekthåndteringen, som jeg ikke dækker i denne blog, og fokuserer på udviklingsmetoden så .. ( hvad er det egentlig at jeg gerne vil have fokus på her ? ) En kort beskrivelse af nogle iterative systemudviklings metoder for at dække de relevante områder. Eksempler på udviklings metoder Feature-Driven Development Test-Driven Development Behavior-Driven Development Grundlæggende principper og tilgang FDD er en model-drevet proces, hvor udviklingsarbejdet struktureres omkring små, veldokumenterede funktioner, der kan implementeres på få dage. Fokus ligger på at opretholde kontinuerlig fremdrift og at levere funktionalitet, der er reel og målbar. De 5 processer i FDD FDD følger fem nøgleprocesser: Udarbejdelse af en overordnet model (Develop an Overall Model): Projektet starter med en forståelse af domænet og en model, som beskriver systemets kernestruktur og -adfærd. Dette involverer workshops og samarbejde mellem udviklere og domæneeksperter. Udarbejdelse af en funktionel liste (Build a Features List): Udviklerne opdeler systemet i mindre dele, kaldet funktioner. Funktionerne beskrives som \"handlinger udført på et resultat for en given kunde\" og organiseres i områder (business domains). Planlægning baseret på funktioner (Plan by Feature): Funktionerne prioriteres og grupperes i udviklingsmilepæle. Denne proces skaber en detaljeret plan, som guider det iterative arbejde. Design af funktioner (Design by Feature): Hver funktion designes af et lille team i tæt samarbejde, hvor designet sikrer, at funktionen kan implementeres på en struktureret måde. Implementering af funktioner (Build by Feature): Funktionerne kodes, testes og integreres i systemet. Denne proces gentages iterativt, indtil projektet er færdigt. Wikipedia Test-Driven Development (TDD) er en softwareudviklingsmetodologi, hvor testskrivning er integreret som en central del af udviklingsprocessen. Det er en iterativ udviklingsmetode, der fokuserer på at skrive tests før implementering af funktionalitet. Hovedidéen bag TDD TDD har som kerneprincip at skrive automatiserede tests for den ønskede funktionalitet, før selve implementeringen påbegyndes. Det hjælper med at sikre, at al kode, der skrives, opfylder kravene og fungerer korrekt. Denne tilgang understøtter hurtigere fejlidentifikation og sikrer, at ny kode ikke bryder eksisterende funktionalitet. TDD-processen TDD følger en fast cyklus, kendt som Red-Green-Refactor: Red (skriv en test) Start med at skrive en test, der beskriver en ny funktion eller en ændring. Testen skal fejle, fordi funktionaliteten endnu ikke er implementeret. Green (implementer funktionalitet): Skriv netop nok kode til at få testen til at bestå. Dette sikrer, at udviklingen er fokuseret og minimal. Refactor (forbedr koden): Optimer koden uden at ændre dens adfærd. Refactorering sikrer, at koden er nemmere at læse og vedligeholdelsesvenlig, mens alle tests stadig passerer. Processen gentages for hver ny funktion eller ændring, hvilket sikrer en iterativ og kontrolleret udviklingsproces. Levende dokumentation: Tests fungerer som dokumentation for systemets funktionalitet og kan bruges til at forstå, hvad koden gør. Eksempel på TDD i praksis Lad os sige, at vi skal udvikle en funktion til at beregne summen af to tal: Red: Skriv en test, der kontrollerer, om Add(2, 3) returnerer 5. Testen fejler, fordi funktionen endnu ikke er implementeret. Green: Implementér en simpel version af funktionen: public int Add(int a, int b) { return a + b; } Testen består nu. Refactor: Overvej, om koden kan optimeres eller generaliseres. Wikipedia Behavior-Driven Development (BDD) er en softwareudviklingsmetodologi, der bygger videre på Test-Driven Development (TDD) og fokuserer på at fremme samarbejde mellem udviklere, testere og forretningsinteressenter. BDD er designet til at hjælpe teams med at forstå og definere, hvordan en applikation skal opføre sig i forskellige situationer. Hovedidéen bag BDD BDD sigter mod at bygge en fælles forståelse af applikationens krav ved at beskrive dem i et simpelt og klart sprog, der er forståeligt for både tekniske og ikke-tekniske interessenter. Fokus er på at definere \"adfærden\" (behavior) af softwaren i forhold til forretningsværdi og brugeroplevelse. Denne tilgang gør brug af specifikationer skrevet i naturligt sprog kombineret med eksekverbare tests, der fungerer som dokumentation for applikationens forventede adfærd. Nøgleprincipper i BDD Samarbejde mellem roller: BDD fremmer samarbejde mellem udviklere, testere og forretningsinteressenter for at sikre, at alle har en fælles forståelse af kravene. Brug af naturligt sprog: Krav beskrives ofte i et format som Gherkin-syntaks, hvilket gør det lettere at dele og forstå. Eksekverbare specifikationer: Testene fungerer både som kravspecifikation og dokumentation. De kører automatisk og bekræfter, at applikationen opfører sig som forventet. BDD's struktur: Given-When-Then BDD bruger ofte et Given-When-Then mønster til at definere funktionaliteter og scenarier: Given: En given kontekst eller forudsætning. When: En bestemt handling eller hændelse. Then: Den forventede adfærd eller resultat. Eksempel: Scenario: User logs in successfully Given the user is on the login page When they enter valid credentials Then they should be redirected to the dashboard Cucumber: Bruges til at skrive og køre Gherkin-scenarier. SpecFlow: En .NET-implementering af Cucumber. Disse værktøjer integrerer med testautomatiseringsværktøjer og gør det muligt at køre scenarierne som testcases. Wikipedia. Eksempler på brug af termer i forhold til Minimal API vs. Controllers Når man beslutter, hvilke termer der passer bedst i en given situation, afhænger det af, om man arbejder med Controllers eller Minimal API, da strukturen og organiseringen af kode varierer. Controller Minimal API Bruger man controllers i .NET, vil det være en ide at tænke over hvad der dækker en gruppe af endpoints (TODO: eksempel). Bruger man Minimal API, hvor at et endpoint kan være i en fil for sig selv, kan man reflektere over hvilken term man bruger for 1 enkelt endpoint (TODO: eksempel). Eksempel: Brug af termer for grupperede endpoints Theme (højere niveau): \"User Management\" kan være temaet for alle endpoints, der håndterer brugere. Epic: \"Manage Users\" kan være en overordnet epic, som beskriver flere funktioner såsom oprettelse, redigering, og sletning af brugere. Feature: En feature kan være \"User Registration\". Story: En specifik story kan være \"As an admin, I want to register a new user with email and password.\" Konkrete eksempler på endpoints i en UserController: POST /users – Opret bruger (story for User Registration). GET /users/{id} – Hent bruger. PUT /users/{id} – Opdater bruger. DELETE /users/{id} – Slet bruger. Her vil en controller give mening som en gruppering for endpoints relateret til \"User Management\", og man kan bruge termer som feature eller story til at specificere formålet med hvert endpoint. Med Minimal API kan hvert endpoint implementeres uafhængigt, ofte i sin egen fil. Dette gør det muligt at tænke på hvert endpoint som en isoleret enhed, og terminologien kan tilpasses denne granularitet. Eksempel: Brug af termer for enkeltstående endpoints Feature: Et enkelt endpoint kan ses som en feature i sig selv, fx \"User Registration\". Story: Et endpoint kan implementere en specifik story, fx \"As an admin, I want to delete a user by ID.\" Konkrete eksempler på Minimal API-endpoints i separate filer: CreateUserEndpoint.cs: Copy code app.MapPost(\"/users\", (UserDto user) => { // Logic for creating a user }).WithTags(\"User Management\"); Term: Feature/story → \"User Registration.\" DeleteUserEndpoint.cs: Copy code app.MapDelete(\"/users/{id}\", (int id) => { // Logic for deleting a user }).WithTags(\"User Management\"); Term: Story → \"Delete a user by ID.\" Med Minimal API kan man fokusere på mere granulære termer, da hvert endpoint ofte er implementeret for sig selv og ikke nødvendigvis grupperes naturligt som i controllers. Valget af termer afhænger af, hvordan kodebasen er struktureret: Controller-tilgang: Brug termer som theme og epic til at beskrive grupper af endpoints og feature eller story til at beskrive individuelle endpoints inden for en gruppe. Minimal API: Brug mere detaljerede termer, hvor hvert endpoint kan beskrives som en feature eller story, da de ofte ikke grupperes på samme måde. Det vigtigste er, at teamet er enige om terminologien og dens anvendelse. Hvordan kagen skal skæres og med hvilke værktøjer er ikke hugget i sten. Det vigtigste er at man kender mulighederne så man kan bruge dem som det passer bedst."
  },
  "docs/processen.html": {
    "href": "docs/processen.html",
    "title": "Processen | dadaPipes",
    "keywords": "Processen"
  },
  "implementering/authentication.html": {
    "href": "implementering/authentication.html",
    "title": "Authentication | dadaPipes",
    "keywords": "Authentication Authentication i Blazor Standalone er et sandt mareridt. Det kan få selv den mest hårdhudede udvikler til at tvivle på sit erhverv. Kommer snart ..."
  },
  "implementering/blazor.html": {
    "href": "implementering/blazor.html",
    "title": "Blazor | dadaPipes",
    "keywords": "Blazor Intro Jeg havde valgt Blazor Standalone fordi at jeg var sikker på at det var det eneste der understøttede PWA, hvilket var et vigtigt krav til applikationen. Men det viste sig senere, efter at have udviklet den første Epic, at det ikke kun var Standalone der understøttede PWA. Det var en dyr fejl, da det gjorde mange ting meget mere besværligt. Af skade bliver man klog, men lige det her kunne jeg godt have været foruden. Da Blazor Standalone, som med React, Vue og Angular, ikke kræver en .NET server til at serve UI'en, er der ikke helt så meget der støtter Blazor Standalone, som fx Blazor Web App, der kræver en .NET server for at serve UI'en. Oven i hatten, så er Blazor som et front end framework, der ikke er afhængig af en bestemt form for server, ikke så populært som fx React, Angular og Vue. Derfor eksisterer der heller ikke dokumentation for Blazor Standalone, på lige fod med de Java Script baserede frameworks. På den ene side ville det have været meget nemmere, hvis jeg havde valgt Blazor Web App, hvor jeg bare kunne scaffolde eksempelvis, Docker og Identity i applikationen, så det havde virket på magisk vis, hvor at Client og Server spiller sammen fra start. På den anden side, så fik jeg lært noget om hvordan tingene fungere bag om det magiske tæppe. Lad os starte hårdt ud fra toppen Main Layout @using Microsoft.AspNetCore.Components.Routing @using MudBlazor @inherits LayoutComponentBase <MudThemeProvider /> <MudPopoverProvider /> <MudDialogProvider /> <MudSnackbarProvider /> <MudLayout> <MudAppBar Elevation=\"1\"> <AuthorizeView Roles=\"Admin\"> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Secondary\" OnClick=\"@ToggleDrawer\"> Admin</MudButton> </AuthorizeView> <MudNavLink Href=\"/\" Match=\"NavLinkMatch.All\"> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\"> Home</MudButton> </MudNavLink> <AuthorizeView Roles=\"Admin, Judge, DogHandler\"> <Authorized> <MudNavLink Href=\"/logout\" Match=\"NavLinkMatch.All\"> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\"> Logout</MudButton> </MudNavLink> </Authorized> <NotAuthorized> <MudNavLink Href=\"/login\"> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\"> Login</MudButton> </MudNavLink> </NotAuthorized> </AuthorizeView> </MudAppBar> <MudDrawer @bind-Open=\"@_open\" ClipMode=\"DrawerClipMode.Always\" Elevation=\"2\" Variant=\"@DrawerVariant.Temporary\" Color=\"Color.Primary\"> <MudDrawerHeader> <MudText Typo=\"Typo.h6\">Admin</MudText> </MudDrawerHeader> <MudNavMenu> <MudNavLink Match=\"NavLinkMatch.All\" Href=\"/admin/guide\" Icon=\"@Icons.Material.Filled.People\" IconColor=\"Color.Inherit\"> Admin Guide</MudNavLink> <MudNavLink Match=\"NavLinkMatch.All\" Href=\"/admin/users\" Icon=\"@Icons.Material.Filled.LocalLibrary\" IconColor=\"Color.Inherit\"> Manage Users</MudNavLink> <MudNavGroup Title=\"Edit Template\" Icon=@Icons.Material.Filled.AddModerator IconColor=\"Color.Inherit\" Expanded=\"false\"> <MudNavLink Match=\"NavLinkMatch.All\" Href=\"/admin/template\"> Rallyfield Templates</MudNavLink> <MudNavLink Match=\"NavLinkMatch.All\" Href=\"/admin/rallyfield-rules\"> Rallyfield Rules</MudNavLink> </MudNavGroup> <MudNavLink Match=\"NavLinkMatch.All\" Href=\"/admin/claims\" Icon=@Icons.Material.Filled.AddModerator IconColor=\"Color.Inherit\"> Claims</MudNavLink> </MudNavMenu> </MudDrawer> <MudMainContent> @Body </MudMainContent> </MudLayout> @code { private bool _open = false; private void ToggleDrawer() { _open = !_open; } } ExerciseForm.cs @inject ImageProcessingService ImageService @inject ExerciseService ExerciseService @inject TypeService TypeService @inject TempoService TempoService @inject ObstacleService ObstacleService; <MudForm Model=\"exercise\" @ref=\"form\" Validation=\"@(validator.ValidateValue)\" ValidationDelay=\"0\"> <MudTextField @bind-Value=\"exercise.Number\" For=\"@(() => exercise.Number)\" Immediate=\"true\" Label=\"Number\" Variant=\"Variant.Outlined\" Class=\"mx-4\" /> <MudTextField @bind-Value=\"exercise.Name\" For=\"@(() => exercise.Name)\" Immediate=\"true\" Label=\"Name*\" Variant=\"Variant.Outlined\" Class=\"mx-4\" /> <MudTextField @bind-Value=\"exercise.Description\" For=\"@(() => exercise.Description)\" Immediate=\"true\" Label=\"Description\" Lines=\"5\" Variant=\"Variant.Outlined\" Class=\"mx-4\" /> <MudField Class=\"ma-4\" Variant=\"Variant.Outlined\"> <MudText Typo=\"Typo.h6\" Class=\"ma-4\">Side Handling</MudText> <MudCheckBox @ref=\"LeftHandledCheckbox\" @bind-Value=\"exercise.PositionLeft\" For=\"@(() => exercise.PositionLeft)\" Label=\"Left\" Class=\"mx-4\" /> <MudCheckBox @ref=\"RightHandledCheckbox\" @bind-Value=\"exercise.PositionRight\" For=\"@(() => exercise.PositionRight)\" Label=\"Right\" Class=\"mx-4\" /> </MudField> <MudSelect @ref=\"levelSelect\" T=\"GetLevelTemplate\" @bind-Value=\"selectedLevel\" ToStringFunc=\"@(l => l.Name)\" Variant=\"Variant.Outlined\" MultiSelection=\"false\" Label=\"Select level\" Class=\"ma-4\"> @foreach (var level in levels) { <MudSelectItem T=\"GetLevelTemplate\" Value=\"@level\"> @level.Name </MudSelectItem> } </MudSelect> <MudSelect @ref=\"typeSelect\" @bind-SelectedValues=\"selectedTypes\" ToStringFunc=\"@(t => t.Name)\" Variant=\"Variant.Outlined\" MultiSelection=\"true\" Label=\"Select exercise types\" Class=\"ma-4\"> @foreach (var type in types) { <MudSelectItem T=\"GetTypeTemplate\" Value=\"@type\"> @type.Name </MudSelectItem> } </MudSelect> <MudSelect @ref=\"tempoSelect\" @bind-SelectedValues=\"selectedTempos\" ToStringFunc=\"@(t => t.Name)\" Variant=\"Variant.Outlined\" MultiSelection=\"true\" Label=\"Select exercise tempos\" Class=\"ma-4\"> @foreach (var tempo in tempos) { <MudSelectItem T=\"GetTempoTemplate\" Value=\"@tempo\"> @tempo.Name </MudSelectItem> } </MudSelect> <MudSelect @ref=\"obstacleSelect\" @bind-SelectedValues=\"selectedObstacles\" ToStringFunc=\"@(t => t.Name)\" Variant=\"Variant.Outlined\" MultiSelection=\"true\" Label=\"Select obstacles\" Class=\"ma-4\"> @foreach (var obstacle in obstacles) { <MudSelectItem T=\"GetObstacleTemplate\" Value=\"@obstacle\"> @obstacle.Name </MudSelectItem> } </MudSelect> <MudField Class=\"ma-4\" Variant=\"Variant.Outlined\"> <MudStack Class=\"pa-4\"> @if (!string.IsNullOrEmpty(b64)) { <MudImage Src=\"@b64\" Alt=\"Uploaded Image\" ObjectFit=\"ObjectFit.Contain\" Width=\"100\" /> } <MudFileUpload @ref=\"@imageUpload\" T=\"IBrowserFile\" @bind-Files=\"uploadedImage\" Accept=\".png, .jpg, .jpeg\" OnFilesChanged=\"UploadImageToFormAsync\" MaximumFileCount=\"1\"> <ActivatorContent> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\" StartIcon=\"@Icons.Material.Filled.CloudUpload\"> Upload image file </MudButton> </ActivatorContent> </MudFileUpload> </MudStack> </MudField> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\" Class=\"ml-auto\" OnClick=\"@(async () => await Submit())\"> Save </MudButton> </MudForm> @code { [Inject] ISnackbar snackbar { get; set; } MudForm form = new(); MudCheckBox<bool> LeftHandledCheckbox = new(); MudCheckBox<bool> RightHandledCheckbox = new(); MudSelect<GetLevelTemplate> levelSelect = new(); MudSelect<GetTypeTemplate> typeSelect = new(); MudSelect<GetTempoTemplate> tempoSelect = new(); MudSelect<GetObstacleTemplate> obstacleSelect = new(); IBrowserFile? uploadedImage; MudFileUpload<IBrowserFile>? imageUpload; string b64; CreateExerciseTemplate exercise = new(); CreateExerciseTemplateValidator validator = new(); GetLevelTemplate selectedLevel = new(); List<GetLevelTemplate> levels = []; IEnumerable<GetTypeTemplate> selectedTypes = []; public List<GetTypeTemplate> types = []; IEnumerable<GetTempoTemplate> selectedTempos = []; public List <GetTempoTemplate> tempos = []; IEnumerable<GetObstacleTemplate> selectedObstacles = []; public List<GetObstacleTemplate> obstacles = []; [Parameter] public EventCallback<GetExerciseTemplate> OnExerciseAdded { get; set; } public void LoadLevels(List<GetLevelTemplate> levels) { this.levels = levels; } public void LoadPartialTemplateData(List<GetLevelTemplate> levels, List<GetTypeTemplate> types, List<GetTempoTemplate> tempos, List<GetObstacleTemplate> obstacles) { this.levels = levels; this.types = types; this.tempos = tempos; this.obstacles = obstacles; //StateHasChanged(); } public void AddNewLevel(GetLevelTemplate level) { levels.Add(level); StateHasChanged(); } public void AddNewExerciseType(GetTypeTemplate type) { types.Add(type); StateHasChanged(); } public void AddNewExerciseTempo(GetTempoTemplate tempo) { tempos.Add(tempo); StateHasChanged(); } public void AddNewObstacle(GetObstacleTemplate obstacle) { obstacles.Add(obstacle); StateHasChanged(); } public void UpdateLevel(GetLevelTemplate updatedLevel) { var levelToRemove = levels.Find(t => t.Id == updatedLevel.Id); if (levelToRemove is not null) { levels.Remove(levelToRemove); levels.Add(updatedLevel); typeSelect.Clear(); StateHasChanged(); } else { snackbar.Add(\"Could not find type\", Severity.Error); Console.WriteLine(\"Could not find type to remove before update.\"); return; } } public void UpdateExerciseType(GetTypeTemplate updatedType) { var typeToRemove = types.Find(t => t.Id == updatedType.Id); if (typeToRemove is not null) { types.Remove(typeToRemove); types.Add(updatedType); typeSelect.Clear(); StateHasChanged(); } else { snackbar.Add(\"Could not find type\", Severity.Error); Console.WriteLine(\"Could not find type to remove before update.\"); return; } } public void UpdateExerciseTempo(GetTempoTemplate updatedTempo) { var tempoToRemove = tempos.Find(t => t.Id == updatedTempo.Id); if (tempoToRemove is not null) { tempos.Remove(tempoToRemove); tempos.Add(updatedTempo); tempoSelect.Clear(); StateHasChanged(); } else { snackbar.Add(\"Could not find tempo\", Severity.Error); Console.WriteLine(\"Could not find tempo to remove before update.\"); return; } } public void UpdateObstacle(GetObstacleTemplate updatedObstacle) { var obstacleToRemove = obstacles.Find(t => t.Id == updatedObstacle.Id); if (obstacleToRemove is not null) { obstacles.Remove(obstacleToRemove); obstacles.Add(updatedObstacle); obstacleSelect.Clear(); StateHasChanged(); } else { snackbar.Add(\"Could not find type\", Severity.Error); Console.WriteLine(\"Could not find type to remove before update.\"); return; } } public void RemoveExerciseTypeTemplate(GetTypeTemplate type) { types.Remove(type); typeSelect.Clear(); StateHasChanged(); } public void RemoveTempoTemplate(GetTempoTemplate tempo) { tempos.Remove(tempo); tempoSelect.Clear(); StateHasChanged(); } public void RemoveObstacle(GetObstacleTemplate obstacle) { obstacles.Remove(obstacle); obstacleSelect.Clear(); StateHasChanged(); } async Task Submit() { await form.Validate(); if (!form.IsValid) { snackbar.Add(\"Invalid form\", Severity.Error); return; } try { var createdExercise = await ExerciseService.CreateExerciseAsync(exercise, selectedLevel, selectedTypes, selectedTempos, selectedObstacles, uploadedImage); await form.ResetAsync(); exercise.PositionLeft = false; exercise.PositionRight = false; await imageUpload.ClearAsync(); b64 = string.Empty; await typeSelect.Clear(); await tempoSelect.Clear(); await obstacleSelect.Clear(); await OnExerciseAdded.InvokeAsync(createdExercise); snackbar.Add(\"Exercise succesfully Saved.\", Severity.Success); } catch (HttpRequestException ex) { snackbar.Add(\"An error occurred while saving. Please check your network connection.\", Severity.Error); Console.WriteLine($\"HTTP error: {ex.Message}\"); } catch (InvalidOperationException ex) { snackbar.Add(\"An error occurred while processing the response from the server.\", Severity.Error); Console.WriteLine($\"Invalid operation: {ex.Message}\"); } catch (Exception ex) { snackbar.Add(\"An unexpected error occurred while saving the exercice template.\", Severity.Error); Console.WriteLine($\"Unexpected error: {ex.Message}\"); } } async Task UploadImageToFormAsync() { var fileSizeBytes = uploadedImage.Size; try { // Log the initial file size Console.WriteLine($\"Initial file size: {fileSizeBytes} bytes\"); if (fileSizeBytes >= 512000) // Max size for Base64 conversion { Console.WriteLine($\"File size exceeds {512000 / 1024 / 1024:F2} MB limit\"); snackbar.Add(\"Max file size for Base64 conversion is 0.5 MB\", Severity.Warning); } b64 = await ImageService.ConvertToBase64Async(uploadedImage); } catch (Exception ex) { Console.WriteLine($\"Error during upload: {ex.Message}\"); snackbar.Add(\"An error occurred doing image upload\", Severity.Error); } } } De forskellige dele af en exercise, består af mindre dele som en bruger har valgt i de forudgående forms. Jeg har samlet variablerne i LoadPartialTemplateData() som argumenter, for at kunne samle dem, og lavet den public, så den kan modtage data fra andre steder i applikationen og opdatere komponenten. FluentValidation .NET bibliotek for validering. Det er et meget populært og udbredt, men Blazor understøtter det ikke direkte, da det primært er for Server side. Da en af hovedårsagerne til at jeg valgte Blazor til min .NET API, var at jeg kunne bruge C# klasser eller records til DTO's, så jeg kunne bruge de samme objekter i både front og backend. Ved at bruge de samme objekter til at transportere data mellem front og backend, kan jeg bruge den samme validerings kode i begge ender, i stedet for at holde styr på validering begge steder, eller droppe validering i front end, da det ville være nemmere at holde styr på og det vigtigste at sikre er serveren. Med MudBlazor kan jeg bruge Fluent validation i mine DTO's og bruge de DTO's i både Blazor components og i mine endpoints og dermed nå frem til den samme validering i både front- og backend. CreateExerciseTemplate exercise som er den model jeg bruger for exerciseTemplate formen er en implementering af CreateExerciseTemplate. validator er en implementering af CreateExerciseTemplateValidator der validerer CreateExerciseTemplate namespace DogObedience.Shared.Admin.Templates.ExerciseTemplate; public class CreateExerciseTemplate { public bool IsTemplate { get; set; } = true; public int Number { get; set; } public string Name { get; set; } = string.Empty; public string Description { get; set; } = string.Empty; public bool PositionLeft { get; set; } public bool PositionRight { get; set; } public string Color { get; set; } = string.Empty; public int LevelId { get; set; } public ICollection<CreateTypeTemplate> Types { get; set; } = []; public ICollection<CreateTempoTemplate> Tempos { get; set; } = []; public ICollection<CreateObstacleTemplate> Obstacles { get; set; } = []; public IFormFile? ImageFile { get; set; } } public class CreateExerciseTemplateValidator : AbstractValidator<CreateExerciseTemplate> { public CreateExerciseTemplateValidator() { RuleFor(x => x.Number).NotEmpty(); RuleFor(x => x.Name).NotEmpty(); RuleFor(x => x.Description).NotEmpty(); RuleFor(x => x.ImageFile.Length).LessThanOrEqualTo(512000); // Max size for Base64 conversion RuleFor(x => x.Types).NotEmpty(); RuleFor(x => x.Tempos).NotEmpty(); RuleFor(x => x.Obstacles).NotEmpty(); } public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) => { var result = await ValidateAsync(ValidationContext<CreateExerciseTemplate>.CreateWithOptions((CreateExerciseTemplate)model, x => x.IncludeProperties(propertyName))); if (result.IsValid) return Array.Empty<string>(); return result.Errors.Select(e => e.ErrorMessage); }; } ExerciseDataGrid Er af tilsvarende kompleksitet som ExerciseForm @inject ExerciseService ExerciseService @inject TypeService TypeService @inject TempoService TempoService @inject ObstacleService ObstacleService; @inject ImageProcessingService ImageService @if (exercises == null || exercises.Count() == 0) { <p>No exercise created yet.</p> } <MudDataGrid T=\"GetExerciseTemplate\" Items=\"@exercises\" ReadOnly=\"@false\" EditMode=\"@DataGridEditMode.Form\" Bordered=\"true\" Dense=\"true\" Hover=\"true\" EditTrigger=\"@DataGridEditTrigger.OnRowClick\" CommittedItemChanges=\"@CommittedItemChanges\"> <Columns> <PropertyColumn Property=\"x => x.Number\" /> <PropertyColumn Property=\"x => x.Name\" /> <PropertyColumn Property=\"x => x.Description\" /> <PropertyColumn Property=\"x => x.Types\"> <EditTemplate> <MudSelect T=\"GetTypeTemplate\" @bind-SelectedValues=\"@context.Item.Types\" ToStringFunc=\"@(t => t.Name)\" MultiSelection=\"true\"> @foreach (var type in types) { <MudSelectItem T=\"GetTypeTemplate\"> @type.Name </MudSelectItem> } </MudSelect> </EditTemplate> <CellTemplate> @string.Join(\", \", context.Item.Types.Select(x => x.Name)) </CellTemplate> </PropertyColumn> <PropertyColumn Property=\"x => x.Tempos\"> <EditTemplate> <MudSelect T=\"GetTempoTemplate\" @bind-SelectedValues=\"@context.Item.Tempos\" ToStringFunc=\"@(t => t.Name)\" MultiSelection=\"true\"> @foreach (var tempo in tempos) { <MudSelectItem T=\"GetTempoTemplate\"> @tempo.Name </MudSelectItem> } </MudSelect> </EditTemplate> <CellTemplate> @string.Join(\", \", context.Item.Tempos.Select(x => x.Name)) </CellTemplate> </PropertyColumn> <PropertyColumn Property=\"x => x.PositionLeft\" Title=\"Left Handled\"> <EditTemplate> <MudCheckBox @bind-Value=\"context.Item.PositionLeft\" Label=\"Left\"/> </EditTemplate> </PropertyColumn> <PropertyColumn Property=\"x => x.PositionRight\" Title=\"Right Handled\"> <EditTemplate> <MudCheckBox @bind-Value=\"context.Item.PositionRight\" Label=\"Right\"/> </EditTemplate> </PropertyColumn> <PropertyColumn Property=\"x => x.Obstacles\"> <EditTemplate> <MudSelect T=\"GetObstacleTemplate\" @bind-SelectedValues=\"@context.Item.Obstacles\" ToStringFunc=\"@(o => o.Name)\" MultiSelection=\"false\"> @foreach (var obstacle in obstacles) { <MudSelectItem T=\"GetObstacleTemplate\"> @obstacle.Name </MudSelectItem> } </MudSelect> </EditTemplate> <CellTemplate> <MudStack Row=\"true\" Class=\"d-flex align-center\"> <MudText>@string.Join(\", \", context.Item.Obstacles.Select(x => x.Name))</MudText> @if (context.Item.B64 is not null) { <MudImage Src=\"@context.Item.B64\" Alt=\"Exercise Image\" ObjectFit=\"ObjectFit.Contain\" Width=\"100\" /> } else { <p>No image available</p> } </MudStack> </CellTemplate> </PropertyColumn> <PropertyColumn Property=\"x => x.ImageFile\" Title=\"Image\"> <EditTemplate> <MudFileUpload @ref=\"@imageUpload\" T=\"IBrowserFile\" @bind-Files=\"@context.Item.ImageFile\" Accept=\".png, .jpg, .jpeg\" OnFilesChanged=\"async (e) => await UploadImageToDataGridAsync(context.Item.ImageFile)\" MaximumFileCount=\"1\"> <ActivatorContent> <MudButton Variant=\"Variant.Filled\" Color=\"Color.Primary\" StartIcon=\"@Icons.Material.Filled.CloudUpload\"> Upload image file </MudButton> </ActivatorContent> </MudFileUpload> </EditTemplate> <CellTemplate> @if (context.Item.B64 is not null) { <MudImage Src=\"@context.Item.B64\" Alt=\"Exercise Image\" ObjectFit=\"ObjectFit.Contain\" Width=\"100\" /> } else { <p>No image available</p> } </CellTemplate> </PropertyColumn> <TemplateColumn CellClass=\"d-flex justify-end\"> <CellTemplate> <MudIconButton Size=\"@Size.Medium\" Icon=\"@Icons.Material.Filled.Delete\" Color=\"Color.Error\" OnClick=\"async (e) => await DeleteExerciseAsync(context.Item.Id)\" /> </CellTemplate> </TemplateColumn> </Columns> </MudDataGrid> @code { [Inject] ISnackbar snackbar { get; set; } string dataGridB64 = string.Empty; IBrowserFile image; MudFileUpload<IBrowserFile> imageUpload; List<GetLevelTemplate> levels = []; List<GetExerciseTemplate> exercises = []; List<GetTypeTemplate> types = []; List<GetTempoTemplate> tempos = []; List<GetObstacleTemplate> obstacles = []; public void LoadExerciseTemplates(List<GetExerciseTemplate> exercises) { this.exercises = exercises; StateHasChanged(); } public void LoadPartialTemplateData(List<GetLevelTemplate> levels, List<GetTypeTemplate> types, List<GetTempoTemplate> tempos, List<GetObstacleTemplate> obstacles) { this.levels = levels; this.types = types; this.tempos = tempos; this.obstacles = obstacles; StateHasChanged(); } public void AddNewExercise(GetExerciseTemplate newExerciseType) { exercises.Add(newExerciseType); StateHasChanged(); } async Task CommittedItemChanges(GetExerciseTemplate exercise) { try { var updatedExercise = await ExerciseService.UpdateExerciseTemplateAsync(exercise); var exerciseToRemove = exercises.Find(e => e.Id == exercise.Id); if(exercise is not null) { exercises.Remove(exerciseToRemove); exercises.Add(updatedExercise); } StateHasChanged(); snackbar.Add(\"Exercise succesfully updated\", Severity.Success); } catch (HttpRequestException ex) { snackbar.Add(\"An error occurred while saving. Please check your network connection.\", Severity.Error); Console.WriteLine($\"HTTP error: {ex.Message}\"); } catch (InvalidOperationException ex) { snackbar.Add(\"An error occurred while processing the response from the server.\", Severity.Error); Console.WriteLine($\"Invalid operation: {ex.Message}\"); } catch (Exception ex) { snackbar.Add(\"An unexpected error occurred while updating exercise template.\", Severity.Error); Console.WriteLine($\"Unexpected error: {ex.Message}\"); } } async Task DeleteExerciseAsync(int? id) { try { await ExerciseService.DeleteExerciseTemplateAsync(id); var exerciseToRemove = exercises.Find(p => p.Id == id); if (exerciseToRemove is not null) { exercises.Remove(exerciseToRemove); snackbar.Add(\"Exercise template successfully deleted.\", Severity.Success); } else { snackbar.Add(\"No exercise template found with the given ID.\", Severity.Warning); } } catch (HttpRequestException ex) { snackbar.Add(\"An error occurred while saving. Please check your network connection.\", Severity.Error); Console.WriteLine($\"HTTP error: {ex.Message}\"); } catch (InvalidOperationException ex) { snackbar.Add(\"An error occurred while processing the response from the server.\", Severity.Error); Console.WriteLine($\"Invalid operation: {ex.Message}\"); } catch (Exception ex) { snackbar.Add(\"An unexpected error occurred while deleting exercise templates.\", Severity.Error); Console.WriteLine($\"Unexpected error: {ex.Message}\"); } } async Task UploadImageToDataGridAsync(IBrowserFile image) => dataGridB64 = await ImageService.ConvertToBase64Async(image); } ExerciseService Har ansvaret for at send og modtage data fra Serveren. Da jeg ikke kunne sende en fil som en del af et C# object, men stadig skulle sende 1 object til serveren, endte det med at jeg måtte bruge et multipartformdatacontent og så mappe hver property til en navngiven multipartformdata property. Jeg skulle så samtidig sørge for at det endpoint jeg sender multipartformdata objektet til, er sat op så at det kan modtage et objekt der har de samme property navne og variabler. Hovedårsagen til denne kompleksitet er at man ikke kan stole på hvad som bliver uploaded på Client side. Havde koden været på serveren, havde den været mere sikker, og jeg ville kunne scanne den for virus og sende den direkte til en database eller et blob storage. namespace DogObedience.Client.Features.Admin.Templates.ExerciseTemplate; public class ExerciseService { private readonly HttpClient _httpClient; private readonly ImageProcessingService _imageProcessingService; public ExerciseService(HttpClient httpClient, ImageProcessingService imageProcessingService) { _httpClient = httpClient; _imageProcessingService = imageProcessingService; } public async Task<GetExerciseTemplate> CreateExerciseAsync( CreateExerciseTemplate exercise, GetLevelTemplate selectedLevel, IEnumerable<GetTypeTemplate> selectedTypes, IEnumerable<GetTempoTemplate> selectedTempos, IEnumerable<GetObstacleTemplate> selectedObstacles, IBrowserFile imageFile) { try { var content = new MultipartFormDataContent { // Exercise template data { new StringContent(exercise.Number.ToString()), \"Number\" }, { new StringContent(exercise.Name), \"Name\" }, { new StringContent(exercise.Description), \"Description\" }, { new StringContent(exercise.PositionLeft.ToString()), \"PositionLeft\" }, { new StringContent(exercise.PositionRight.ToString()), \"PositionRight\" }, // Level template data { new StringContent(selectedLevel.Id.ToString()), \"LevelId\" }, { new StringContent(selectedLevel.Name), \"Level.Name\" }, { new StringContent(selectedLevel.Color), \"Color\" }, }; // Types int typeIndex = 0; foreach (var type in selectedTypes) { content.Add(new StringContent(type.IsTemplate.ToString()), $\"Types[{typeIndex}].IsTemplate\"); content.Add(new StringContent(type.Name), $\"Types[{typeIndex}].Name\"); typeIndex++; } // Tempos int tempoIndex = 0; foreach (var tempo in selectedTempos) { content.Add(new StringContent(tempo.IsTemplate.ToString()), $\"Tempos[{tempoIndex}].IsTemplate\"); content.Add(new StringContent(tempo.Name), $\"Tempos[{tempoIndex}].Name\"); tempoIndex++; } // Obstacles int obstacleIndex = 0; foreach (var obstacle in selectedObstacles) { content.Add(new StringContent(obstacle.IsTemplate.ToString()), $\"Obstacles[{obstacleIndex}].IsTemplate\"); content.Add(new StringContent(obstacle.Name), $\"Obstacles[{obstacleIndex}].Name\"); content.Add(new StringContent(obstacle.B64), $\"Obstacles[{obstacleIndex}].B64\"); obstacleIndex++; } // ImageFile await using var fileStream = imageFile.OpenReadStream(); using var streamContent = new StreamContent(fileStream); streamContent.Headers.ContentType = new MediaTypeHeaderValue(imageFile.ContentType); content.Add(streamContent, \"ImageFile\", imageFile.Name); var response = await _httpClient.PostAsync(\"api/admin/field-template/level-template/exercise-template\", content); if (!response.IsSuccessStatusCode) { var errorContent = await response.Content.ReadAsStringAsync(); throw new HttpRequestException($\"Request failed with status code {response.StatusCode}: {errorContent}\"); } var createdExercise = await response.Content.ReadFromJsonAsync<GetExerciseTemplate>(); if (createdExercise is not null) { return createdExercise; } throw new InvalidOperationException(\"Failed to deserialize the response content.\"); } catch (HttpRequestException ex) { Console.WriteLine($\"An HTTP error occurred: {ex.Message}\"); throw; } catch (Exception ex) { Console.WriteLine($\"An unexpected error occurred: {ex.Message}\"); throw; } } public async Task<List<GetExerciseTemplate>> GetExerciseTemplatesAsync() { try { var response = await _httpClient.GetAsync(\"api/admin/field-template/level-template/exercise-template\"); if (!response.IsSuccessStatusCode) { if (response.StatusCode == HttpStatusCode.NotFound) return []; var errorContent = await response.Content.ReadAsStringAsync(); throw new HttpRequestException($\"Request failed with status code {response.StatusCode}: {errorContent}\"); } var exercises = await response.Content.ReadFromJsonAsync<List<GetExerciseTemplate>>(); if (exercises is not null) { return exercises; } throw new InvalidOperationException(\"Failed to deserialize the response content.\"); } catch (HttpRequestException ex) { Console.WriteLine($\"An HTTP error occurred: {ex.Message}\"); throw; } catch (Exception ex) { Console.WriteLine($\"An unexpected error occurred: {ex.Message}\"); throw; } } public async Task<GetExerciseTemplate> UpdateExerciseTemplateAsync(GetExerciseTemplate exercise) { if (exercise == null) throw new ArgumentNullException(nameof(exercise), \"Exercise cannot be null.\"); if (exercise.Level == null) throw new ArgumentNullException(nameof(exercise.Level), \"Exercise.Level cannot be null.\"); try { var content = new MultipartFormDataContent { // Exercise template data { new StringContent(exercise.Id.ToString()), \"Id\" }, { new StringContent(exercise.IsTemplate.ToString()), \"IsTemplate\" }, { new StringContent(exercise.Number.ToString()), \"Number\" }, { new StringContent(exercise.Name), \"Name\" }, { new StringContent(exercise.Description), \"Description\" }, { new StringContent(exercise.PositionLeft.ToString()), \"PositionLeft\" }, { new StringContent(exercise.PositionRight.ToString()), \"PositionRight\" }, { new StringContent(exercise.B64), \"B64\" }, // Level template data { new StringContent(exercise.LevelId.ToString()), \"LevelId\" }, { new StringContent(exercise.Level.Name), \"Level.Name\" }, { new StringContent(exercise.Level.Color), \"Level.Color\" } }; // Types int typeIndex = 0; foreach (var type in exercise.Types) { content.Add(new StringContent(type.Id.ToString()), $\"Types[{typeIndex}].Id\"); content.Add(new StringContent(type.IsTemplate.ToString()), $\"Types[{typeIndex}].IsTemplate\"); content.Add(new StringContent(type.Name), $\"Types[{typeIndex}].Name\"); typeIndex++; } // Tempos int tempoIndex = 0; foreach (var tempo in exercise.Tempos) { content.Add(new StringContent(tempo.Id.ToString()), $\"Tempos[{tempoIndex}].Id\"); content.Add(new StringContent(tempo.IsTemplate.ToString()), $\"Tempos[{tempoIndex}].IsTemplate\"); content.Add(new StringContent(tempo.Name), $\"Tempos[{tempoIndex}].Name\"); tempoIndex++; } // Obstacles int obstacleIndex = 0; foreach (var obstacle in exercise.Obstacles) { content.Add(new StringContent(obstacle.Id.ToString()), $\"Obstacles[{obstacleIndex}].Id\"); content.Add(new StringContent(obstacle.IsTemplate.ToString()), $\"Obstacles[{obstacleIndex}].IsTemplate\"); content.Add(new StringContent(obstacle.Name), $\"Obstacles[{obstacleIndex}].Name\"); if (exercise.ImageFile is not null) { var b64 = await _imageProcessingService.ConvertToBase64Async(exercise.ImageFile); content.Add(new StringContent(b64), $\"Obstacles[{obstacleIndex}].B64\"); } else { content.Add(new StringContent(exercise.B64), $\"Obstacles[{obstacleIndex}].B64\"); } obstacleIndex++; } var response = await _httpClient.PutAsync($\"api/admin/field-template/level-template/exercise-template/{exercise.Id}\", content); if (!response.IsSuccessStatusCode) { var errorContent = await response.Content.ReadAsStringAsync(); throw new HttpRequestException($\"Request failed with status code {response.StatusCode}: {errorContent}\"); } var updatedExercise = await response.Content.ReadFromJsonAsync<GetExerciseTemplate>(); if (updatedExercise is not null) { return updatedExercise; } throw new InvalidOperationException(\"Failed to deserialize the response content.\"); } catch (HttpRequestException ex) { Console.WriteLine($\"An HTTP error occurred: {ex.Message}\"); throw; } catch (Exception ex) { Console.WriteLine($\"An unexpected error occurred: {ex.Message}\"); throw; } } public async Task DeleteExerciseTemplateAsync(int? id) { if (id is null) { throw new ArgumentNullException(nameof(id), \"ID cannot be null\"); } try { var response = await _httpClient.DeleteAsync($\"api/admin/field-template/level-template/exercise-template/{id}\"); if (!response.IsSuccessStatusCode) { var errorContent = await response.Content.ReadAsStringAsync(); throw new HttpRequestException($\"Request failed with status code {response.StatusCode}: {errorContent}\"); } } catch (HttpRequestException ex) { Console.WriteLine($\"An HTTP error occurred: {ex.Message}\"); throw; } catch (Exception ex) { Console.WriteLine($\"An unexpected error occurred: {ex.Message}\"); throw; } } }"
  },
  "implementering/docker.html": {
    "href": "implementering/docker.html",
    "title": "Docker | dadaPipes",
    "keywords": "Docker Det endte med at jeg gav op på at Containerize min applikation. Det var lykkedes for mig med en prototype, men der findes ingen muligheder for at komme nemt fra start, eller noget dokumentation for hvordan at man gør. Endnu en årsag til at jeg vil vælge en anden form for serverless frontend, hvis det skulle være et krav. Scaffold docker i .NET Web API Højreklik på server projektet klik på Docker support.. Vælg dette Container OS: Linux Container Build Type: Dockerfile Container Image Distro: Default (8) Docker Build Context: ... Det scaffolder 'Dockerfile' i roden af folderen og ser sådan her ud: # See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging. # This stage is used when running from VS in fast mode (Default for Debug configuration) FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base USER $APP_UID WORKDIR /app EXPOSE 8080 EXPOSE 8081 # This stage is used to build the service project FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build ARG BUILD_CONFIGURATION=Release WORKDIR /src COPY [\"DogObedience.Server/DogObedience.Server.csproj\", \"DogObedience.Server/\"] COPY [\"DogObedience.Client/DogObedience.Client.csproj\", \"DogObedience.Client/\"] COPY [\"DogObedience.Shared/DogObedience.Shared.csproj\", \"DogObedience.Shared/\"] RUN dotnet restore \"./DogObedience.Server/DogObedience.Server.csproj\" COPY . . WORKDIR \"/src/DogObedience.Server\" RUN dotnet build \"./DogObedience.Server.csproj\" -c $BUILD_CONFIGURATION -o /app/build # This stage is used to publish the service project to be copied to the final stage FROM build AS publish ARG BUILD_CONFIGURATION=Release RUN dotnet publish \"./DogObedience.Server.csproj\" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false # This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration) FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\"dotnet\", \"DogObedience.Server.dll\"] Ovenstående fil er ikke helt korrekt, da jeg gerne vil hoste mit Server og Client projekt hver for sig. Derfor skal de selfølgelig have hver deres container. Client projektet fjernes og jeg saniterer det en smule, så det er nemmere at se hvad der sker. Server og Shared projekterne beholdes. Server, fordi at det er det vi gerne vil containorize, og Shared fordi at det bliver brugt i Server projektet og gerne skulle hostes sammen: # Use the ASP.NET Core runtime as the base image FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base WORKDIR /app EXPOSE 8080 # Use the .NET SDK to build the project FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build ARG BUILD_CONFIGURATION=Release WORKDIR /src # Copy and restore dependencies COPY ./DogObedience.Shared/ /src/DogObedience.Shared/ COPY ./DogObedience.Server/DogObedience.Server.csproj ./DogObedience.Server/ WORKDIR /src/DogObedience.Server RUN dotnet restore \"./DogObedience.Server.csproj\" # Copy the entire source and build COPY ./DogObedience.Server/. ./ RUN dotnet build \"./DogObedience.Server.csproj\" -c $BUILD_CONFIGURATION -o /app/build # Publish the app in a separate stage FROM build AS publish ARG BUILD_CONFIGURATION=Release RUN dotnet publish \"./DogObedience.Server.csproj\" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false # Final stage: Run the application FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\"dotnet\", \"DogObedience.Server.dll\"] Nu er det tid til at containorize Client projeket: Tilføj en fil i roden af klient projektet. Lav en .txt fil, giv det navnet Dockerfile og slet .txt efterfølgende Tilføj en fil i roden af klient projektet. giv det navnet nginx.conf nginx er en web server og den har vi brug for, for at kunne serve HTML, CSS og Java Script, i Standalone. Hvis jeg ikke har nævnt det noget andet sted i bloggen, så er Blazor Standalone et serverless framework. Det vil sige at den ikke er afhængig af en .NET server til at 'serve' HTML, CSS og Java Script. Derfor skal der en server til for at kunne 'serve' det. events { } http { include mime.types; types { application/wasm wasm; } server { listen 80; index index.html; location / { root /usr/share/nginx/html; try_files $uri $uri/ /index.html =404; } } } Dockerfile i Client projektet: # Build Stage FROM mcr.microsoft.com/dotnet/sdk:8.0-alpine AS build-env WORKDIR /app # Copy the client and shared .csproj files and restore dependencies COPY ./DogObedience.Client/DogObedience.Client.csproj ./DogObedience.Client/ COPY ./DogObedience.Shared/DogObedience.Shared.csproj ./DogObedience.Shared/ RUN dotnet restore \"./DogObedience.Client/DogObedience.Client.csproj\" # Copy the rest of the client and shared project files COPY ./DogObedience.Client/ ./DogObedience.Client/ COPY ./DogObedience.Shared/ ./DogObedience.Shared/ # Publish the client project WORKDIR /app/DogObedience.Client RUN dotnet publish -c Release -o output # Nginx Stage FROM nginx:alpine WORKDIR /usr/share/nginx/html # Copy the published output to the Nginx HTML folder COPY --from=build-env /app/DogObedience.Client/output/wwwroot . # Specify the path for nginx.conf from the context directory COPY ./DogObedience.Client/nginx.conf /etc/nginx/nginx.conf # Expose port 80 for the client EXPOSE 80 Så er det tid til Docker-compose, så jeg kan orkestrerer containerne. Højre klik på Server projektet => Add => Container Orchestrator Support => OK => OK Det giver 3 filer: .dockerignore Den lader vi stå som den er launchSettings.json Så jeg kan trykke på den grønne pil i VS 2022 og spinne containerne op, uden at bruge CLI'en. { \"profiles\": { \"Docker Compose\": { \"commandName\": \"DockerCompose\", \"commandVersion\": \"1.0\", \"serviceActions\": { \"fastrallyobedience.server\": \"StartDebugging\" } } } } Docker-compose Den fil der får det hele til at spille sammen, så man kun behøver at køre 1 fil for at få containerne op at spinde. Important context . Servicene tager udgangspunkt i root af solution. Det tog mig pinligt lang tid at finde ud af hvorfor at jeg ikke kunne få det til at virke. Hvis ikke at man sætter udgangspunktet til *root så skal man huske på at docker-compose.yml filen, i dette tilfælde er placeret inde i docker-compose folderen. services: DogObedience.server: build: context: . dockerfile: ./DogObedience.Server/Dockerfile ports: - \"8080:8080\" # HTTP depends_on: - sqlserver sqlserver: image: mcr.microsoft.com/mssql/server:2022-latest environment: MSSQL_SA_PASSWORD: \"myStrong_Password123#\" ACCEPT_EULA: \"Y\" ports: - \"1433:1433\" DogObedience.client: build: context: . dockerfile: ./DogObedience.Client/Dockerfile ports: - \"80:80\" Client, Server og en SQLServer er de containere jeg gerne skal have op at køre. Når jeg bruger kommandoen docker-compose up --build ser det umiddelbart ud til at fungere, men jeg har glemt en ting: Microsoft.Data.SqlClient.SqlException (0x80131904): A network-related or instance-specific error occurred while establishing a connection to SQL Server. The server was not found or was not accessible."
  },
  "implementering/server.html": {
    "href": "implementering/server.html",
    "title": "Server | dadaPipes",
    "keywords": "Server Controller CreateExerciseTemplate og UpdateExerciseTemplate er begge de samme objekter som er brugt i Blazor komponenterne. Det vil sige at de har den samme validering. Hvis der skulle være en ondsindet bruger der forsøger sig med at sende korupt data ned til serveren, Fx 150% rabat, så får brugeren ikke penge tilbage, hver gang at de køber noget. Nu er dette ikke en online shop, men ideen er den samme. Vi vil kun have saniteret data ned til vores server, hvor de basekyttede dele af forretings logikken ligger. Det er ikke altid at det er nok at sanitere data ved kun at lade bestemte typer af data med bestemte navne få adgang. Filer kan gå hen og være et et våben, som kryptonit er for Superman. Man ved aldrig hvad der gemmer sig, uanset hvad file typen er, da det kan spoofes. Det har ikke været et særligt højt krav, og har derfor ikke haft et så stort fokus, da det er meget få og betroede brugere der kommer til at have adgang til at uploade filer. Derfor er det ikke noget der er blevet implementeret. Man kan bruge data annotations til at få ASP.NET Core til at lave json output som kan bruges af biblioteker som Swagger til at lave testbar dokumentation. Eksemplet herunder vil dokumentere at enpointed kan give en Status code 400 BadRequest. [ProducesResponseType(StatusCodes.Status400BadRequest)] Hvad jeg så fandt ud af senere hen var at det var fuldstændigt unødigt, da de kan dokumentere sig selv med web API conventions. Så sparer man da de linier kode. namespace DogObedience.Server.Features.Admin.Templates.ExerciseTemplate; [ApiExplorerSettings(GroupName = \"admin/templates\")] [Authorize(Roles = \"Admin\")] [Route(\"api/admin/field-template/level-template/exercise-template\")] [ApiController] public class ExerciseController : ControllerBase { private readonly ExerciseService _exerciseService; public ExerciseController(ExerciseService service) { _exerciseService = service; } [HttpPost] [ProducesResponseType(StatusCodes.Status201Created, Type = typeof(GetExerciseTemplate))] [ProducesResponseType(StatusCodes.Status400BadRequest)] public async Task<IActionResult> CreateExerciseTemplate([FromForm] CreateExerciseTemplate exercise) { var result = await _exerciseService.CreateExerciseTemplateAsync(exercise); return StatusCode(201, result.Value); } [HttpGet] [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(List<GetExerciseTemplate>))] [ProducesResponseType(StatusCodes.Status204NoContent)] [ProducesResponseType(StatusCodes.Status400BadRequest)] public async Task<IActionResult> GetAllExerciseTemplates() { var result = await _exerciseService.GetAllExerciseTemplatesAsync(); if (result.IsFailed) return NotFound(result.Errors); return Ok(result.Value); } [HttpPut(\"{id}\")] public async Task<IActionResult> UpdateExerciseTemplate(int id, [FromForm] UpdateExerciseTemplate exercise) { var updatedExercise = await _exerciseService.UpdateExerciseTemplate(id, exercise); return Ok(updatedExercise); } [HttpDelete(\"{id}\")] [ProducesResponseType(StatusCodes.Status204NoContent)] [ProducesResponseType(StatusCodes.Status400BadRequest)] [ProducesResponseType(StatusCodes.Status404NotFound)] public async Task<IActionResult> DeleteExerciseTemplate(int id) { var result = await _exerciseService.DeleteExerciseTemplate(id); if (result.IsFailed) return NotFound(result.Errors); return NoContent(); } } Service public async Task<GetExerciseTemplate> UpdateExerciseTemplate(int dtoId, UpdateExerciseTemplate exerciseToUpdate) { var existingExercise = await _context.Exercises .Include(e => e.Tempos) .Include(e => e.Level) .Include(e => e.Types) .Include(e => e.Obstacles) .FirstOrDefaultAsync(e => e.Id == dtoId) ?? throw new Exception(\"Exercise template not found.\"); // Update basic properties of the exercise _context.Entry(existingExercise).CurrentValues.SetValues(exerciseToUpdate); // Update the LevelId if (exerciseToUpdate.LevelId != 0) { var existingLevel = await _context.Levels.FirstOrDefaultAsync(l => l.Id == exerciseToUpdate.LevelId) ?? throw new Exception(\"Level not found.\"); existingExercise.LevelId = existingLevel.Id; } // Update Types var typesToRemove = existingExercise.Types .Where(existingType => exerciseToUpdate.Types.All(t => t.Id != existingType.Id)) .ToList(); _context.ExerciseTypes.RemoveRange(typesToRemove); foreach (var type in exerciseToUpdate.Types) { var existingType = existingExercise.Types.FirstOrDefault(et => et.Id == type.Id); if (existingType != null) { _context.Entry(existingType).CurrentValues.SetValues(type); } else { existingExercise.Types.Add(new ExerciseType { Name = type.Name, IsTemplate = type.IsTemplate, ExerciseId = dtoId // Set foreign key }); } } // Update Tempos var temposToRemove = existingExercise.Tempos .Where(existingTempo => exerciseToUpdate.Tempos.All(t => t.Id != existingTempo.Id)) .ToList(); _context.ExerciseTempos.RemoveRange(temposToRemove); foreach (var tempo in exerciseToUpdate.Tempos) { var existingTempo = existingExercise.Tempos.FirstOrDefault(et => et.Id == tempo.Id); if (existingTempo != null) { _context.Entry(existingTempo).CurrentValues.SetValues(tempo); } else { existingExercise.Tempos.Add(new ExerciseTempo { Name = tempo.Name, IsTemplate = tempo.IsTemplate, ExerciseId = dtoId // Set foreign key }); } } // Update Obstacles var obstaclesToRemove = existingExercise.Obstacles .Where(existingObstacle => exerciseToUpdate.Obstacles.All(o => o.Id != existingObstacle.Id)) .ToList(); _context.Obstacles.RemoveRange(obstaclesToRemove); foreach (var obstacle in exerciseToUpdate.Obstacles) { var existingObstacle = existingExercise.Obstacles.FirstOrDefault(o => o.Id == obstacle.Id); if (existingObstacle != null) { _context.Entry(existingObstacle).CurrentValues.SetValues(obstacle); } else { existingExercise.Obstacles.Add(new Obstacle { Name = obstacle.Name, IsTemplate = obstacle.IsTemplate, B64 = obstacle.B64, ExerciseId = dtoId // Set foreign key }); } } // Save changes to the database await _context.SaveChangesAsync(); // Map the updated exercise to the DTO and return var updatedExercise = _map.ToGetExercise(existingExercise); return updatedExercise; } async Task<string> ConvertToB64(IFormFile image) { await using var ms = new MemoryStream(); await image.CopyToAsync(ms); var bytes = ms.ToArray(); var b64 = Convert.ToBase64String(bytes); return $\"data:{image.ContentType};base64,{b64}\"; } Mapper public void UpdateToEntity(Exercise e, UpdateExerciseTemplate dto) { // Update basic properties e.Id = dto.Id; e.Number = dto.Number; e.IsTemplate = dto.IsTemplate; e.Name = dto.Name; e.Description = dto.Description; e.PositionLeft = dto.PositionLeft; e.PositionRight = dto.PositionRight; e.B64 = dto.B64; e.LevelId = dto.LevelId; // Remove types that exist in the database but not in the DTO var typesToRemove = e.Types .Where(existingType => !dto.Types.Any(dtoType => dtoType.Id == existingType.Id)) .ToList(); foreach (var typeToRemove in typesToRemove) { e.Types.Remove(typeToRemove); } // Add or update types from DTO foreach (var type in dto.Types) { var existingType = e.Types.FirstOrDefault(et => et.Id == type.Id); if (existingType != null) { // Update existing entity existingType.IsTemplate = false; existingType.Name = type.Name; } else { // Add new entity e.Types.Add(new ExerciseType { IsTemplate = false, Name = type.Name }); } } // Update Tempos // Find existing tempos to remove var temposToRemove = e.Tempos .Where(existingTempo => dto.Tempos.All(dtoTempo => dtoTempo.Id != existingTempo.Id)) .ToList(); foreach (var tempoToRemove in temposToRemove) { e.Tempos.Remove(tempoToRemove); } // Add or update tempos from DTO foreach (var tempoDto in dto.Tempos) { var existingTempo = e.Tempos.FirstOrDefault(et => et.Id == tempoDto.Id); if (existingTempo != null) { // Update existing entity existingTempo.Name = tempoDto.Name; } else { // Add new entity e.Tempos.Add(new ExerciseTempo { IsTemplate = false, Name = tempoDto.Name }); } } } De metoder der er gennemgået her er nok til den slemme side når det kommer til kompleksitet. Men det illusterer meget godt hvordan mindre at målet med færre driftomkostninger kan få implementerings- og vedligeldelsesomkostningerne til at stige."
  },
  "index.html": {
    "href": "index.html",
    "title": "Blazor & .NET | dadaPipes",
    "keywords": "Blazor & .NET \"Who pays the piper picks the tune\" Denne tankegang gælder også i softwareudvikling, hvor produktsejeren eller kunden, som finansierer projektet, ofte har det sidste ord i beslutninger om teknologi og arkitektur. Men som udviklere har vi et ansvar for at præsentere de forskellige muligheder og deres konsekvenser – både fordele, ulemper og omkostninger. Det handler om at skabe gennemsigtighed, så kunden kan træffe informerede valg, med fokus på udviklings-, vedligeholds- og driftsomkostninger. Hvad udvikler teamet har erfaring med og er mest komfortabel med, er sekundært, og skal helst ikke spille en større role. Hvis de værktøjer der vælges ligger inden for .NET, og teamet ikke har erfaring med de specifike værktøjer, så må man vælge at sende sine medarbejdere på et kursus, for at man kan løfte opgaven og levere et produkt der bedst muligt lever op til kravene. Teamet må tilpasse sig kravene og ikke omvendt. I denne blog er udgangspunktet kunden. Det primære mål er at gøre teknologien og processerne forståelige for kunden, så de kan navigere systemets funktioner og deltage aktivt i beslutningsprocesserne. Dette gør jeg ved at tage fat på følgende emner: Blazor-varianter Hvordan valg af framework påvirker brugeroplevelse og systemets fleksibilitet. Arkitekturvalg Overvejelser omkring monolitter kontra distribuerede systemer, herunder API’er og microservices, og hvordan disse påvirker skalerbarhed og vedligeholdelse. Udviklingsmetoder og tests Hvordan vi kan sikre kvalitet og stabilitet gennem acceptancetest og Gherkin-baserede user stories, som samtidig fungerer som dokumentation for kunden. Docker Hvordan containerisering gør det muligt for kunden selv at teste systemet manuelt, inden det skubbes i produktion. Dokumentation Organiseret på en måde, der afspejler applikationens struktur, og som gør det nemt for kunden at finde og forstå specifikke funktioner. Det sekundære mål er at skabe en bro mellem kunden og udviklerne. Ved at bruge teknologier og værktøjer, der er gennemsigtige og velbeskrevne, bliver tekniske beslutninger et samarbejde, hvor både kundens vision og systemets behov er i fokus. Hvilke værktøjer skal man vælge og hvorfor/vælge det rigtige værktøj til jobbet ? (intern link) Hvordan sikrer man at kunden får dækket alle krav til systemet ? (intern link) Hordan sikrer man at ændringer i systemet fremover ikke skaber problemer andre steder i systemet ? (internt link). Hvordan sikrer man en dækkende og overskuelig dokumentation som er nem at lave og vedligeholde ? og sikrer at den er korrekt (forkert dokumentation er værre end ikke at have nogen dokumentation) ? (internt link)"
  },
  "læringsmål.html": {
    "href": "læringsmål.html",
    "title": "Læringsmål | dadaPipes",
    "keywords": "Læringsmål Primære: Blazor og ASP.NET Viden (Huske of Forstå) Blazor Identificere forskelle mellem Blazor Server og Blazor WebAssembly – herunder forskellen mellem Bazor WebAssembly og Blazor Server, og hvilke fordele og ulemper de hver især medfører. ASP.NET Core Redegøre for ASP.NET Core’s arkitektur og anvendelse i webudvikling, herunder hvordan frameworket understøtter skalerbarhed og responsive API’er. Færdigheder (Anvende og Analysere) Blazor Udvikle og tilpasse komponenter i Blazor til at skabe en brugervenlig og interaktiv frontend. ASP.NET Core Implementere RESTful API’er med ASP.NET Core, der effektivt håndterer CRUD-operationer og understøtter integrationen med en frontend udviklet i Blazor. Analyse af dataflow og komponentinteraktioner i Blazor – analysere, hvordan data håndteres og udveksles effektivt mellem Blazor-komponenter og backend. Kompetencer (Evaluere og Skabe) Evaluering af teknologi: Bedømme og begrunde valget mellem Blazor WebAssembly og Blazor Server baseret på performancekrav, udviklingstid og brugerbehov. Design og udvikling af en samlet webapplikation: Kombinere Blazor og ASP.NET Core i en skalerbar løsning, der håndterer både frontend og backend på en måde, der understøtter både brugervenlighed og dataintegritet. Sekundære: Database, Sikkerhed og Docker Viden (Huske og Forstå) Database: Forklare grundlæggende databaseoperationer og forstå forskellen mellem relationelle og NoSQL-databaser. Sikkerhed: Identificere centrale sikkerhedsprincipper, såsom autentifikation og autorisation, og hvordan de kan implementeres i ASP.NET Core. Docker: Redegøre for Docker’s anvendelsesområder i softwareudvikling, herunder containerisering af applikationer for at sikre konsistens og skalerbarhed. Færdigheder (Anvende og Analysere) Database: Behandle data med Entity Framework Core i ASP.NET Core, samt integrere databasen med Blazor-frontend. Sikkerhed: Implementere basale sikkerhedsmekanismer i ASP.NET Core, f.eks. via autentifikation og beskyttelse af API’er. Docker: Afprøve og applikationen i en Docker-container, hvilket muliggør lettere test og drift på tværs af forskellige miljøer. Kompetencer (Evaluere og Skabe) Sikkerhedsvurdering: Evaluere og sikre backend-løsningen mod almindelige trusler. Feedbackhåndtering og iterativ udvikling: Sikre kontinuerlig forbedring af applikationen ved at facilitere feedback fra Product Owner gennem iterativ udvikling, hvor test og evaluering muliggøres ved at trække den nyeste version fra Docker Hub."
  }
}